<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />



<meta name="progressive" content="true" />
<meta name="allow-skip" content="true" />
<meta name="learnr-version-prerender" content="0.11.4.9000" />

<title>ASCR Tutorial</title>

<!-- header-includes START -->
<!-- HEAD_CONTENT -->
<!-- header-includes END -->
<!-- HEAD_CONTENT -->

<!-- highlightjs -->
<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>


<!-- taken from https://github.com/rstudio/rmarkdown/blob/de8a9c38618903627ca509f5401d50a0876079f7/inst/rmd/h/default.html#L293-L343 -->
<!-- tabsets -->
<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>
<!-- end tabsets -->


</head>

<body>
<a class='sr-only sr-only-focusable visually-hidden-focusable' href='#learnr-tutorial-content'>Skip to Tutorial Content</a>



<div class="pageContent band">
<main class="bandContent page">

<article class="topics" id="learnr-tutorial-content">

<style type="text/css">
div.learnBox{border-color:#668BA4;border-style:solid;background-color:rgba(151,203,169,0.5);width:100%;padding:0.5em;border-radius:10px;margin:0 auto}div.learnBox strong{color:#668BA4}div.defBox{border-color:#668BA4;border-style:solid;width:100%;padding:0.5em;border-radius:5px;margin:0 auto}div.defBox strong{color:black}
</style>
<div id="section-welcome" class="section level2">
<h2>Welcome!</h2>
<ul>
<li><p>introduction &amp; background</p></li>
<li><p>purpose &amp; intended audience</p></li>
<li><p>link to report</p></li>
<li><p>tutorial structure and outline</p></li>
<li><p>words in blue and bold have been defined in the
definitions</p></li>
<li><p>instructions on how to download package</p></li>
</ul>
</div>
<div id="section-introduction" class="section level2">
<h2>Introduction</h2>
<p>Understanding wildlife populations is super important when it comes
to ecological research and conservation. Specifically, knowing how many
individuals make up a population allows us to identify significant
changes that might lead to extinction, effectively manage populations
and motivate for change in policies and behavior. But calculating
abundance and density of a population is not that easy, it is nearly
impossible to count all individuals in a wildlife population. So over
the years, scientists have come up with many different ways to
<strong>estimate</strong> abundance, like plot sampling, removal
methods, change-in-ratio, distance sampling, and capture-recapture
methods. We then end up with a subset of the actual population otherwise
known as a <strong>sample</strong>.</p>
<p><img src="images/Mind%20Map.png" width="75%" style="display: block; margin: auto;" /></p>
<p>The last two methods, distance sampling (DS) and capture-recapture
methods (CR), are very popular methods. DS typically relies on spotting
animals, whereas CR is an analytical framework that can be used in
conjunction with a variety of methods for capturing or detecting
animals, broadly referred to here as sampling or survey techniques. CR
relies on survey techniques that record captures and recaptures of
animals and historically, these techniques required physically capturing
animals, hence the terminology. In recent decades, however, other cool
survey techniques such as camera trapping and DNA sampling have been
developed and people have started to use the terms detections and
redetections as well. Although which pair is more appropriate depends on
the survey technique, people tend to use the terms interchangeably.
Throughout the tutorial, we’ll mostly use detections and redetections.
Many of these survey techniques, including visually having to identify
animals, can sometimes be quite tricky, a bit pricey and even a little
risky.</p>
<p>Acoustic surveying on the other hand, is a practical and
budget-friendly option that works incredibly well for certain wildlife
populations. Acoustic surveying, specifically passive acoustic
surveying, involves placing microphones or any kind of self-contained
recording unit (also known as autonomous recording devices or ARUs for
brevity), throughout a marine or terrestrial environment to record
animal calls (sometimes called cues or vocalisations). The collected
audio data are then processed using various techniques, such as by
expert knowledge, machine learning algorithms, or pattern recognition
software, to detect the specific sounds of the species of interest. So
naturally, this technique can only be used for animals that are
acoustically active and make some kind of identifiable calls. It’s an
incredibly useful technique for species that aren’t easy to see but do
call often, such as the rare and elusive
<a href="https://www.youtube.com/watch?v=COQF0ZI0yKY" target="_blank">
vaquita species</a> (a really cute porpoise that is in need of some
serious conservation) and many other marine mammals. Or animals that
aren’t active during the day and regularly call throughout the night,
like this
<a href="https://animalia.bio/edible-dormouse" target="_blank">
dormouse</a> or this
<a href="https://dosits.org/galleries/audio-gallery/fishes/brown-meagre/" target="_blank">
brown meagre</a>.</p>
<p>There are other benefits to acoustic surveying too. Weather
conditions don’t massively dictate surveying, so a cloudy day won’t
hinder your ability to spot an animal. For animals that make loud
noises, you’ll likely cover a larger area as you’ll be able to record
their calls from far away. Automated data collection is easy to
implement as you can simply leave recording devices to do their thing,
no need to stay out on the field all day. Recent advancements in
algorithmic procedures for noise reduction, call recognition and
identification have also made automated data processing more achievable.
So, a lot more data can be collected and analysed with acoustic
surveying and the more data, the better. Pretty cool right?</p>
<p>Acoustic surveying lends itself towards the CR framework and
consequently, CR models have been developed specifically for data
collected from acoustic surveys. In this tutorial, we’ll cover these
models and how to implement them in R but before that, we need to
understand how our ability to detect animals depends on distance.</p>
<div class="learnBox">
<p><strong>Summary:</strong></p>
<ul>
<li>We need to know how many animals there are in order to effectively
conserve wildlife populations</li>
<li>Two common methods for estimating abundance and density are distance
sampling and capture-recapture</li>
<li>Acoustic surveying is a sampling technique that involves recording
animal vocalisations</li>
<li>Target species must produce calls that are identifiable</li>
<li>Advantages of acoustic surveying:</li>
</ul>
<ol style="list-style-type: decimal">
<li>Relatively inexpensive and straightforward to implement</li>
<li>Powerful survey technique for visually cryptic species that produce
loud or regular calls</li>
<li>Ability to operate independently of light conditions</li>
<li>Greater spatial range of detectability</li>
<li>Lends itself towards automated data collection and processing</li>
</ol>
</div>
</div>
<div id="section-probability-of-detection" class="section level2">
<h2>Probability of detection</h2>
<p>In this tutorial, we assume that our wildlife population is closed.
This means that during our survey, we assume that no new individuals are
joining the population (births or immigration) or individuals leaving
the population (deaths or emigration). In other words, we assume
geographic and demographic closure. The alternative assumption is that
the population is open, requiring a different analysis that has not yet
been developed for acoustic surveys.</p>
<p>Regardless of our assumption, a key task is to estimate the <span
style="color:#668BA4;font-weight:bold;">probability of detection</span>
- the probability that any individual in the population gets detected at
all. This is because most surveys of wild populations are inherently
<strong>imperfect</strong>. When estimating animal abundance, the
probability of detection helps us know how many animals we did not
detect. Knowing the probability of being in our sample enables us to
determine the probability of NOT being in our sample. By estimating this
probability, we take into account <span
style="color:#668BA4;font-weight:bold;">imperfect detection</span> in
our analysis, which would otherwise have produced inaccurate
results.</p>
<p>Let’s have a look at a traditional capture-recapture analysis with an
example.</p>
<div id="section-example-the-cape-moss-frog" class="section level3">
<h3>Example: The Cape Moss Frog</h3>
<p>In the Cape Peninsula of South Africa, this nifty little frog lives
in leaf litter and among thickly vegetated mountain streams and river
banks. It’s the perfect specimen for acoustic surveying because despite
the frog being super tiny (about 20-22mm), it can often be heard by its
high-pitched call (although some people mistake it for a cricket).</p>
<p><img src="images/capemossfrog1.jpeg" width="35%" style=" display: block; margin: 1em auto; border-radius: 2.5%;" /></p>
<p>Let’s imagine we want to estimate this frog population’s density and
place eight microphones throughout a patch of its habitat (see the
arrangement below). Let’s further imagine that we know the locations of
the frogs in that patch (click the “Reveal Frogs” button) and that they
each made one call. We may or may not detect (record) each of the calls
made, and our microphones can detect multiple calls - click the
“Survey!” button to see the resulting data collected.</p>
<p>The table below is a data frame consisting of <span
style="color:#668BA4;font-weight:bold;">detection histories</span>. Each
row is a detection history of a call made and indicates at which
microphone the call was recorded. An entry equal to “1” means that the
call (i.e. row) was recorded at that microphone (i.e. column), and if
not, the entry will be a zero. Click on one of the rows to show you the
frog location and the microphones that detected the call. Below the
detection history data, you’ll also see the actual number of frogs
(<span class="math inline">\(N\)</span>), an estimate of the overall
probability of detection (<span class="math inline">\(p^*\)</span>) and
an estimate of abundance that was calculated as follows:</p>
<p><span class="math display">\[
\text{Estimate of N } = \frac{\text{number of detected frogs}}{p^*}
\]</span> In the above formula, we are correcting for the number of
frogs we missed by dividing by the overall probability of detecting an
individual during the survey - that is, the probability of ever
detecting an individual across all the microphones. To obtain <span
class="math inline">\(p^*\)</span>, we first calculate the probability
of detecting an individual at a microphone (<span
class="math inline">\(p\)</span>) which we can calculate as the
proportions of times we detected an individual (i.e. the proportion of
1s in our whole dataset). Then, the probability of missing an individual
at a microphone is one minus <span class="math inline">\(p\)</span>. But
we have eight microphones, so the probability of missing an individual
that many times is: <span class="math inline">\((1-p)^8\)</span> and the
complement of that is <span class="math inline">\(p^* =
1-(1-p)^8\)</span>, the overall probability of detection.</p>
<div class="row">
<div class="col-sm-6" style="padding-left:23px;">
<button id="addBtn" type="button" class="btn btn-default action-button" style="color: #fff; background-color: #668ba4; border-color: #2e6da4">Reveal frogs</button>
<button id="detBtn" type="button" class="btn btn-default action-button" style="color: #fff; background-color: #668ba4; border-color: #2e6da4">Survey!</button>
<button id="startOverBtn" type="button" class="btn btn-default action-button" style="color: #fff; background-color: #668ba4; border-color: #2e6da4">Start Over</button>
</div>
<div class="col-sm-6" align="right">
<button id="repeatBtn" type="button" class="btn btn-default action-button" style="color: #fff; background-color: #668ba4; border-color: #2e6da4">Repeat x 1000</button>
</div>
</div>
<div class="row">
<div class="col-sm-6">
<div class="shiny-plot-output html-fill-item" id="frogPopPlot" style="width:100%;height:400px;"></div>
</div>
<div class="col-sm-6">
<div class="datatables html-widget html-widget-output shiny-report-size html-fill-item-overflow-hidden html-fill-item" id="captHistData" style="width:100%;height:auto;"></div>
<br/>
<div class="row">
<div class="shiny-html-output col-sm-4" id="trueN"></div>
<div class="shiny-html-output col-sm-4" id="probD"></div>
<div class="shiny-html-output col-sm-4" id="estN"></div>
</div>
</div>
</div>
<div class="row">
<div class="col-sm-12">
<div data-display-if="input.repeatBtn%2 == 1" data-ns-prefix="">
<div class="plotly html-widget html-widget-output shiny-report-size shiny-report-theme html-fill-item-overflow-hidden html-fill-item" id="simPlot" style="width:100%;height:400px;"></div>
</div>
</div>
</div>
<p><br/></p>
<p>Play around a bit, conduct multiple surveys on the same set of frogs
or survey new sets of frogs a few times! You’ll likely notice that our
abundance estimate is usually lower than the actual number of frogs. In
fact, if you click the “Repeat x 1000” button, 1000 surveys of your
current frog population will be conducted and the resulting 1000
estimates will be visualized as a histogram.</p>
<p>Immediately, it is clear the peak of the histogram is relatively far
away from the true value, which tells us that most of the time, we’re
estimating that a smaller number of frogs exist within this habitat
patch. If you’re familiar with statistical terminology, we have shown
through simulation that our estimate is negatively biased. We don’t want
this! Remember, our example is on a very arbitrary scale. In reality,
concluding that your population is much smaller than what actually
exists could lead to misleading decision-making and misplaced
conservation efforts.</p>
<p>So, what’s happening here? The basic CR model assumes constant
detection probability, so essentially, we assume that each call is
equally likely to be detected. But is that true? If you have surveyed a
few times, you’ll see that frogs closer to the microphones are almost
always detected, and frogs within short distances to multiple
microphones get detected various times! The calls made by those frogs
are more likely (i.e. higher probability of detection) to be recorded
than those far away. That means our ability to detect calls depends on
distance; more specifically detection probability decreases with
increasing distance.</p>
</div>
<div id="section-distance-dependent-detection" class="section level3">
<h3>Distance-dependent detection</h3>
<p>Let’s focus on one hypothetical population of 25 frogs we’ve surveyed
once. We know the locations of all the frogs in our population, so we
can measure the straight line distance between each frog and each
microphone.</p>
<p><img src="00_Welcome_files/figure-html/onePopPlot-1.png" width="85%" style="display: block; margin: auto;" /></p>
<br/>
<p>We can plot a histogram of these distances and inspect the frequency
of frogs located within certain distance intervals (or bins). For
example’s sake, we’ll say that we’ve measured distance in meters. A
distance bin is the span of a bar - the first distance bin is from 0 to
10 meters, the second is from 10 to 20 meters and so forth. If you hover
over the bars, the frequency of frogs, i.e. how many frogs are within
that distance bin, is shown.</p>
<p>One frog is in our first distance bin (0 to 10 meters), five in the
second, 12 in the third and so forth. As is, it’s not an extremely
interesting graph, but if we add the amount of frogs we detected within
each distance bin (Click ‘Add detections’), it starts to become a bit
more informative.</p>
<div class="row">
<div class="plotly html-widget html-widget-output shiny-report-size shiny-report-theme html-fill-item-overflow-hidden html-fill-item" id="histDistPlot" style="width:100%;height:400px;"></div>
<div data-display-if="input.propBtn%2 == 1" data-ns-prefix="">
<div class="plotly html-widget html-widget-output shiny-report-size shiny-report-theme html-fill-item-overflow-hidden html-fill-item" id="propPlot" style="width:100%;height:400px;"></div>
</div>
</div>
<br/>
<div class="row" align="center">
<button id="allFrogs" type="button" class="btn btn-default action-button" style="color: #fff; background-color: #668ba4; border-color: #2e6da4">All frogs</button>
<button id="addDet" type="button" class="btn btn-default action-button" style="color: #fff; background-color: #668ba4; border-color: #2e6da4">Detected frogs</button>
<button id="propBtn" type="button" class="btn btn-default action-button" style="color: #fff; background-color: #668ba4; border-color: #2e6da4">Proportions detected</button>
</div>
<p><br/></p>
<p>We can see that we detected the frog within the first distance bin
(so we detected 100% of frogs within 0 to 10 meters of a microphone),
and we missed only one frog in the second distance bin. The number of
frogs we missed starts to increase as our distance bins become larger
until we just didn’t detect any of the frogs anymore. So, as the
distances between frogs and microphones become more extensive, we start
to miss more and more frogs. In fact, the proportion of frogs detected
out of the total frogs gives us our probability of detection within each
distance bin (Click ‘Show proportions’). Now, we can clearly see how
detection probability decreases with distance!</p>
<p>In reality, we don’t know the locations of the animals we did or did
not detect, and we don’t know the exact shape of the relationship
between distance and the probability of detection. So, we need to assume
what we think these aspects look like. This is where spatial
capture-recapture comes in!</p>
<div class="learnBox">
<p><strong>Summary:</strong></p>
<ul>
<li>Wildlife surveys are imperfect; we will never observe all the
individuals of a population during a survey - this is known as imperfect
detection.</li>
<li>For reliable abundance and density estimates, we must estimate the
probability of detection (the probability that any individual in the
population gets detected).</li>
<li>Capture-recapture studies produce data in the form of detection
histories (or capture histories), where an entry of “1” indicates that
the call was recorded and zero otherwise.</li>
<li>Traditional CR analysis produce abundance estimates that are smaller
than what actually exists, which may have serious consequences.</li>
<li>Assuming constant detection probability is unrealistic - detection
probability decreases with distance; the further away an animal is, the
harder it is to detect its calls.</li>
<li>We need to assume the shape of the relationship between distance and
detection probability because, in real life, we don’t know the locations
of the animals.</li>
</ul>
</div>
</div>
</div>
<div id="section-introduction-to-scr" class="section level2">
<h2>Introduction to SCR</h2>
<p>In the previous section, we saw that detection probability varies due
to the spatial relationship (i.e. distance) between animals and
detectors. Traditional mark-recapture analyses overlook this spatial
component by assuming a constant probability of detection regardless of
the distance between the animal and detector. This leads to inaccurate
results, which may have serious consequences. So, some really cool
statistical ecologists developed a solution in the form of <span
style="color:#668BA4;font-weight:bold;">spatially explicit
capture-recapture</span> (SECR or SCR). Sounds very fancy but don’t
worry, it’s relatively straightforward, and we won’t go into much (if
any) statistical detail.</p>
<div id="section-survey-structure" class="section level3">
<h3>Survey structure</h3>
<p>Before looking at the model structure, it is important that we
understand the general structure of SCR data collection. SCR surveys
consist of <span style="color:#668BA4;font-weight:bold;">sessions</span>
and <span style="color:#668BA4;font-weight:bold;">occasions</span>.</p>
<p>A session refers to a discrete period of time during which specific
spatial capture-recapture surveys or parts of surveys are conducted. It
encompasses the entire process of deploying detectors at specific
spatial locations for a certain duration, detecting/capturing,
potentially marking and redetecting/recapturing animals. Different
sessions could refer to repeat surveys of the same area or other areas
within a larger survey region. The important thing is that no
redetections of the same individuals are possible between sessions and
if possible, they are not recorded. Otherwise, the sessions are
indistinguishable, and occasions are shared between sessions.</p>
<p>An occasion refers to a distinct event or time point within a session
when data are collected, i.e. when an individual is detected and/or
redetected. Historically, two survey occasions were necessary to capture
and mark individuals and then a second occasion to possibly recapture
marked and/or unmarked individuals. This is because animals are
physically detained by the detectors used, like pitfall traps or cages.
So multiple occasions are necessary to have recaptures. In acoustic SCR
surveys, redetections of calls can occur between detectors, so it is not
necessary to have at least two occasions; a minimum of one is required.
In other words, detectors that do not physically hold animals only
require a single survey occasion as they typically allow simultaneous
detections and redetections.</p>
<p>In the frog example of Chapter 1, every time you clicked the survey
button on the same set of frogs, you were conducting an occasion within
a single session. If you sampled a new set of frogs, a new session
started with new occasions! Now, we are ready to look at the SCR model
structure.</p>
</div>
<div id="section-scr-components" class="section level3">
<h3>SCR components</h3>
<p>Spatial capture-recapture models consist of three key components, two
sub-models (one for detection probability and one for density) and a
mask defining our survey region:</p>
<p><img src="images/scr_flow4.png" width="50%" style="display: block; margin: auto;" /></p>
<p>The primary purpose of a SCR model is to estimate parameters,
specifically density, of our wildlife population. Mathematically,
density is defined as the intensity of a <span
style="color:#668BA4;font-weight:bold;">spatial point pattern</span>.
Let’s explain these concepts with a simple example. Imagine standing in
a field and tossing a handful of marbles onto the ground. The way those
marbles land and spread out across the field creates a pattern. This
arrangement of marbles on the ground is a spatial point pattern where
the points are the marbles. It’s all about how things are distributed
and spaced out in a certain area, like a snapshot of where things are
located in space.</p>
<p>Now, think about how crowded the field is with marbles. The intensity
of the spatial point pattern refers to how many marbles, on average, you
would expect to find in a given area of the field. So, if many marbles
are close together, the intensity would be high, indicating a dense
pattern. On the other hand, if the marbles are more spread out, the
intensity would be lower, indicating a more sparse pattern. Intensity
helps us understand the overall “busyness” or concentration of points in
the spatial pattern. In this context, the points are the locations of
the animals, and the intensity of the point pattern is the density of
animals.</p>
<p>When we conduct a survey, we collect a sample of the animals and
which animals we detect is dependent on the distance between detectors
and animals. So to estimate density from our sample, we have to account
for the detection process.</p>
</div>
<div id="section-detection-function" class="section level3">
<h3>Detection function</h3>
<p>The first component, the <span
style="color:#668BA4;font-weight:bold;">detection function</span>,
describes this relationship between detection probability and distance.
If we were to plot the shape of the detection function of the basic MR
model we looked at in the previous chapter, it would look like this:</p>
<p><img src="00_Welcome_files/figure-html/flatcurve-1.png" width="624" style="display: block; margin: auto;" /></p>
<p>It is simply a straight line at whatever we estimated our probability
of detection to be (here 0.25). But the histogram of distances we built
reveals a more realistic shape of a typical detection function. The
shape below is called the halfnormal detection function and is often
used in SCR models. The function has two parameters, <span
class="math inline">\(g_0\)</span> and <span
class="math inline">\(\sigma\)</span>, which control certain features of
the curve.</p>
<p><img src="00_Welcome_files/figure-html/detfunc-1.png" width="624" style="display: block; margin: auto;" /></p>
<p><br/> The first parameter, <span class="math inline">\(g_0\)</span>,
specifies the probability of detection when the distance between the
animal and the detector is zero. The second parameter modifies the width
of the shoulder of the curve. It controls how quickly we drop off to
zero probability of detection. Play around with the values of the
parameters below to see how they affect the shape of the
relationship.</p>
<!--SHINY.SINGLETON[aee36e0aa1fe9759814fb9fae3d7cd409bc717b0]-->
<!--/SHINY.SINGLETON[aee36e0aa1fe9759814fb9fae3d7cd409bc717b0]-->
<div class="row">
<div class="col-sm-4">
<form class="well" role="complementary">
<div class="form-group shiny-input-container">
<label class="control-label" id="detFunc-label" for="detFunc">Select Function:</label>
<div>
<select id="detFunc"><option value="Halfnormal" selected>Halfnormal</option>
<option value="Hazard Rate">Hazard Rate</option>
<option value="Exponential">Exponential</option>
<option value="Uniform">Uniform</option>
<option value="Hazard Halfnormal">Hazard Halfnormal</option></select>
<script type="application/json" data-for="detFunc" data-nonempty="">{"plugins":["selectize-plugin-a11y"]}</script>
</div>
</div>
<div class="form-group shiny-input-container">
<label class="control-label" id="g0-label" for="g0">Set value of g0:</label>
<input class="js-range-slider" id="g0" data-skin="shiny" data-min="0" data-max="1" data-from="1" data-step="0.01" data-grid="true" data-grid-num="10" data-grid-snap="false" data-prettify-separator="," data-prettify-enabled="true" data-keyboard="true" data-data-type="number"/>
</div>
<div class="form-group shiny-input-container">
<label class="control-label" id="sigma-label" for="sigma">Set value for σ</label>
<input class="js-range-slider" id="sigma" data-skin="shiny" data-min="0" data-max="20" data-from="5" data-step="1" data-grid="true" data-grid-num="10" data-grid-snap="false" data-prettify-separator="," data-prettify-enabled="true" data-keyboard="true" data-data-type="number"/>
</div>
<div data-display-if="input.detFunc == &#39;Hazard Rate&#39;" data-ns-prefix="">
<div class="form-group shiny-input-container">
<label class="control-label" id="z-label" for="z">Set value for z</label>
<input class="js-range-slider" id="z" data-skin="shiny" data-min="0" data-max="1" data-from="0.5" data-step="0.01" data-grid="true" data-grid-num="10" data-grid-snap="false" data-prettify-separator="," data-prettify-enabled="true" data-keyboard="true" data-data-type="number"/>
</div>
</div>
</form>
</div>
<div class="col-sm-8" role="main">
<div class="shiny-plot-output html-fill-item" id="detFuncPlot" style="width:100%;height:400px;"></div>
</div>
</div>
<p>There are many other detection functions as well! If we think the
relationship between detection probability and distance looks slightly
different, we could specify a different detection function. For example,
the hazard rate function includes an additional parameter, <span
class="math inline">\(z\)</span>, that …. You can explore other
detection functions by selecting from the dropdown list above.</p>
<p>We no longer assume a constant probability of detection; we now have
a mathematical model that describes the probability of detection as a
function of the distance between detectors and animal locations. We tell
the model what we think the shape of our detection function should look
like (i.e. halfnormal, hazard rate etc.) and then the model will
estimate the parameters of the detection function based on the data we
collected. You might be thinking, how do I choose the correct detection
function? Well, statisticians have shown that, for the most part, it
doesn’t really matter which shape you choose! As long as the shape is
reasonable and aligns with what you know about your detectors and target
species.</p>
</div>
<div id="section-mask" class="section level3">
<h3>Mask</h3>
<p>In the frog example of Chapter 1, we conducted an acoustic survey
within a habitat patch with hard boundaries, so our survey region was
clearly defined. In practice, habitats are typically more continuous and
not so well demarcated. We somehow need to define the area we are
sampling from and over which we are estimating density. Let’s think
about what we know.</p>
<p>We know that detection probability tapers off gradually with
distance, but we don’t know the locations of all the animals we did or
did not detect, so we can’t define an exact region. We can however
define a distance beyond which we are super confident we definitely
won’t detect a call. This distance is called the <span
style="color:#668BA4;font-weight:bold;">buffer distance</span> and with
the buffer distance, we are ensuring that our probability of detection
definitely reaches zero within our sampled area. We can then be
confident that we aren’t excluding any of the animals we detected in our
sample, and our estimate of density is defined over a sensible area.</p>
<p>Okay, but what to do with the fact that we don’t know the locations
of the animals we did or did not detect? The buffer distance helps us to
further deal with this. It creates a polygon around our detectors, and
within this polygon, our model will try to estimate probable locations
of the detected animals based on our detections and re-detections of the
same calls across microphones. To do this, we consider all possible
locations where an animal might be within the polygon! This area is a
set of points (or rather coordinates) that form a “mask” around our
detectors and is collectively referred to as a <span
style="color:#668BA4;font-weight:bold;">habitat mask</span>. The buffer
distance is formally defined as the minimum distance between detector
locations and the boundary of the habitat mask.</p>
<p>Play around with the buffer distance below to see how the habitat
mask is defined (note the values on the axes as you increase the
distance).</p>
<div class="container-fluid">
<div class="row" align="center" style="padding-left:30px;">
<div class="form-group shiny-input-container" style="width:35%;">
<label class="control-label" id="buffer-label" for="buffer">Buffer distance</label>
<input class="js-range-slider" id="buffer" data-skin="shiny" data-min="1" data-max="200" data-from="100" data-step="1" data-grid="true" data-grid-num="9.95" data-grid-snap="false" data-prettify-separator="," data-prettify-enabled="true" data-keyboard="true" data-data-type="number"/>
</div>
</div>
<div class="row" align="center">
<div class="shiny-plot-output html-fill-item" id="maskBufferPlot" style="width:100%;height:400px;"></div>
</div>
</div>
<p><br/></p>
<p>The mask can also be modified to more accurately represent the
sampled landscape. By incorporating knowledge about specific habitat
types or areas unsuitable for the target species, we can refine the mask
and exclude regions unlikely to harbour the species of interest. This
leads to more accurate density estimates, focusing the analysis on the
more relevant and suitable areas for the species.</p>
</div>
<div id="section-density-model" class="section level3">
<h3>Density model</h3>
<p>The third component models how the animals are distributed throughout
space. Here we describe how we think the marbles we threw on the field
are spread out - we make assumptions about what the pattern looks
like.</p>
<p>The most basic density model consists of only one parameter, density
itself, and assumes that animals are spread out evenly across space. In
other words, the density of locations is constant throughout our survey
region; there is no rhyme or reason to their distribution. Although
mostly biologically unrealistic as landscapes are complex and consist of
different types of habitats and features, assuming constant density may,
in some cases, still provide reliable estimates of average density. For
example, assuming constant density over small areas is not
unreasonable.</p>
<div class="container-fluid">
<div class="row" align="center" style="padding-left:26px;">
<div class="form-group shiny-input-container" style="width:35%;">
<label class="control-label" id="density-label" for="density">Density (number of locations per hectare)</label>
<input class="js-range-slider" id="density" data-skin="shiny" data-min="0" data-max="200" data-from="25" data-step="1" data-grid="true" data-grid-num="10" data-grid-snap="false" data-prettify-separator="," data-prettify-enabled="true" data-keyboard="true" data-data-type="number"/>
</div>
</div>
<div class="row" align="center">
<div class="shiny-plot-output html-fill-item" id="constantDensityPlot" style="width:100%;height:400px;"></div>
</div>
</div>
<p>Alternatively, we can specify a model that describes density as
varying unequally across space. Animal locations could vary due to, for
example, the spatial arrangement of suitable habitats such as vegetation
type or leaf litter or a spatial trend across the landscape. In the
latter case, we could specify a linear trend or even a quadratic trend
in density by modelling density as a function of the x and y coordinates
of the specified mask.</p>
<p>Landscape features can be anything we think is an essential
determinant of where our target species might be, including things such
as the level of noise coming from human settlements or activities. We
can then model density as a function of such variables, allowing density
to change throughout the survey region accordingly. These features we
call habitat covariates, and for every mask point, we have to have a
value for the chosen habitat covariate. There are different ways of
obtaining data for every mask point, we could have measured at every
point, but this is likely unrealistic for very fine and large habitat
masks. Alternatively, given a few measured points across the survey
region, we could predict the rest using another statistical model (more
on this in later chapters).</p>
<p>Habitat covariates can be categorical, such as the forest volume
covariate below, consisting of low, median and high levels. In that
case, we have three model parameters related to three density estimates,
one for each level of forest volume. They can also be numerical, such as
noise. Then we get a continuous density surface with a predicted density
value for every mask point. Under this model, we have two parameters, a
baseline density when noise is at zero and a parameter describing the
effect of noise on density. We use the effect parameter to predict the
surface you see below.</p>
<div class="container-fluid">
<div class="tabbable">
<ul class="nav nav-tabs" data-tabsetid="1013">
<li class="active">
<a href="#tab-1013-1" data-toggle="tab" data-bs-toggle="tab" data-value="Linear trend">Linear trend</a>
</li>
<li>
<a href="#tab-1013-2" data-toggle="tab" data-bs-toggle="tab" data-value="Quadratic trend">Quadratic trend</a>
</li>
<li>
<a href="#tab-1013-3" data-toggle="tab" data-bs-toggle="tab" data-value="Noise">Noise</a>
</li>
<li>
<a href="#tab-1013-4" data-toggle="tab" data-bs-toggle="tab" data-value="Forest cover">Forest cover</a>
</li>
</ul>
<div class="tab-content" data-tabsetid="1013">
<div class="tab-pane active" data-value="Linear trend" fluid="TRUE" id="tab-1013-1">
<div class="shiny-plot-output html-fill-item" id="linearPlot" style="width:100%;height:400px;"></div>
</div>
<div class="tab-pane" data-value="Quadratic trend" fluid="TRUE" id="tab-1013-2">
<div class="shiny-plot-output html-fill-item" id="quadPlot" style="width:100%;height:400px;"></div>
</div>
<div class="tab-pane" data-value="Noise" fluid="TRUE" id="tab-1013-3">
<div class="row">
<div class="col-sm-6">
<div class="shiny-plot-output html-fill-item" id="noisePlot" style="width:100%;height:400px;"></div>
</div>
<div class="col-sm-6">
<div class="shiny-plot-output html-fill-item" id="noiseDensityPlot" style="width:100%;height:400px;"></div>
</div>
</div>
</div>
<div class="tab-pane" data-value="Forest cover" fluid="TRUE" id="tab-1013-4">
<div class="shiny-plot-output html-fill-item" id="forestPlot" style="width:100%;height:400px;"></div>
</div>
</div>
</div>
</div>
<p>We’ll look into these parameters’ interpretation in more detail in
later chapters. For now, you must understand that we can include habitat
covariates in our model to allow density to vary across the survey
region.</p>
<p>The underlying principle of SCR is to model the spatial distribution
of animals using a predefined spatial density model. This model
describes the spatial point pattern of animal locations within the
survey region. On the other hand, the detection function describes the
probability of detecting an animal based on its distance from the
detector. By combining these two components with a habitat mask, SCR
models estimate density within a defined survey region while accounting
for the spatial variation in detection probability.</p>
<p>Before we move on, let’s ensure we understand some of the core
concepts with a quick quiz. You can try the questions multiple times;
some may have more than one correct answer.</p>
<div class="panel-heading tutorial-quiz-title">Quick quiz</div>
<div class="panel panel-default tutorial-question-container">
<div data-label="quiz1-1" class="tutorial-question panel-body">
<div id="quiz1-1-answer_container" class="shiny-html-output"></div>
<div id="quiz1-1-message_container" class="shiny-html-output"></div>
<div id="quiz1-1-action_button_container" class="shiny-html-output"></div>
<script>if (Tutorial.triggerMathJax) Tutorial.triggerMathJax()</script>
</div>
</div>
<div class="panel panel-default tutorial-question-container">
<div data-label="quiz1-2" class="tutorial-question panel-body">
<div id="quiz1-2-answer_container" class="shiny-html-output"></div>
<div id="quiz1-2-message_container" class="shiny-html-output"></div>
<div id="quiz1-2-action_button_container" class="shiny-html-output"></div>
<script>if (Tutorial.triggerMathJax) Tutorial.triggerMathJax()</script>
</div>
</div>
<div class="panel panel-default tutorial-question-container">
<div data-label="quiz1-3" class="tutorial-question panel-body">
<div id="quiz1-3-answer_container" class="shiny-html-output"></div>
<div id="quiz1-3-message_container" class="shiny-html-output"></div>
<div id="quiz1-3-action_button_container" class="shiny-html-output"></div>
<script>if (Tutorial.triggerMathJax) Tutorial.triggerMathJax()</script>
</div>
</div>
<div class="panel panel-default tutorial-question-container">
<div data-label="quiz1-4" class="tutorial-question panel-body">
<div id="quiz1-4-answer_container" class="shiny-html-output"></div>
<div id="quiz1-4-message_container" class="shiny-html-output"></div>
<div id="quiz1-4-action_button_container" class="shiny-html-output"></div>
<script>if (Tutorial.triggerMathJax) Tutorial.triggerMathJax()</script>
</div>
</div>
<div class="panel panel-default tutorial-question-container">
<div data-label="quiz1-5" class="tutorial-question panel-body">
<div id="quiz1-5-answer_container" class="shiny-html-output"></div>
<div id="quiz1-5-message_container" class="shiny-html-output"></div>
<div id="quiz1-5-action_button_container" class="shiny-html-output"></div>
<script>if (Tutorial.triggerMathJax) Tutorial.triggerMathJax()</script>
</div>
</div>
<div class="panel panel-default tutorial-question-container">
<div data-label="quiz1-6" class="tutorial-question panel-body">
<div id="quiz1-6-answer_container" class="shiny-html-output"></div>
<div id="quiz1-6-message_container" class="shiny-html-output"></div>
<div id="quiz1-6-action_button_container" class="shiny-html-output"></div>
<script>if (Tutorial.triggerMathJax) Tutorial.triggerMathJax()</script>
</div>
</div>
<div class="panel panel-default tutorial-question-container">
<div data-label="quiz1-7" class="tutorial-question panel-body">
<div id="quiz1-7-answer_container" class="shiny-html-output"></div>
<div id="quiz1-7-message_container" class="shiny-html-output"></div>
<div id="quiz1-7-action_button_container" class="shiny-html-output"></div>
<script>if (Tutorial.triggerMathJax) Tutorial.triggerMathJax()</script>
</div>
</div>
<div class="panel panel-default tutorial-question-container">
<div data-label="quiz1-8" class="tutorial-question panel-body">
<div id="quiz1-8-answer_container" class="shiny-html-output"></div>
<div id="quiz1-8-message_container" class="shiny-html-output"></div>
<div id="quiz1-8-action_button_container" class="shiny-html-output"></div>
<script>if (Tutorial.triggerMathJax) Tutorial.triggerMathJax()</script>
</div>
</div>
<div class="panel panel-default tutorial-question-container">
<div data-label="quiz1-9" class="tutorial-question panel-body">
<div id="quiz1-9-answer_container" class="shiny-html-output"></div>
<div id="quiz1-9-message_container" class="shiny-html-output"></div>
<div id="quiz1-9-action_button_container" class="shiny-html-output"></div>
<script>if (Tutorial.triggerMathJax) Tutorial.triggerMathJax()</script>
</div>
</div>
<div class="panel panel-default tutorial-question-container">
<div data-label="quiz1-10" class="tutorial-question panel-body">
<div id="quiz1-10-answer_container" class="shiny-html-output"></div>
<div id="quiz1-10-message_container" class="shiny-html-output"></div>
<div id="quiz1-10-action_button_container" class="shiny-html-output"></div>
<script>if (Tutorial.triggerMathJax) Tutorial.triggerMathJax()</script>
</div>
</div>
<div class="learnBox">
<p><strong>Summary:</strong></p>
<ul>
<li>To combat the issues of traditional mark-recapture models,
statistical ecologists developed spatial capture-recapture (SCR).</li>
<li>SCR models have three key components: detection function, mask and
density model.</li>
<li>The detection function describes the relationship between detection
probability and distance.</li>
<li>The mask defines the area of our study and is a set of coordinates
that form a “mask” around the detectors.</li>
<li>The buffer distance is the minimum distance between a detector and
the edge of the mask.</li>
<li>We describe the distribution of animals through a density
model.</li>
<li>Density can be either constant throughout the survey region or it
can be modelled as a function of habitat covariates and spatial
trends.</li>
<li>SCR models combine sub-models for detection probability and density
together with a habitat mask and in doing so they estimate density
within a defined survey region while accounting for the spatial
variation in detection probability.</li>
</ul>
</div>
</div>
</div>
<div id="section-overview-of-ascr" class="section level2">
<h2>Overview of aSCR</h2>
<p>So far, we have investigated distance-dependent detection and briefly
looked over the structure of an SCR model in the context of acoustic
sampling. When we use an SCR model for acoustic surveys, we refer to it
as acoustic spatial capture-recapture or aSCR for short.</p>
<p>There is an important distinction to make before we can move on to
acoustic data analysis. In the frog example of Chapter 1, we assumed
each frog made one call so we could equate a detected call with one
individual frog. Rarely does an individual, let alone all individuals in
a population, call only once during a survey, and it’s not always
possible to match calls to individuals. In other words, we can’t
typically classify multiple detected calls as belonging to one
individual. In that case, our density model describes the distribution
of <span style="color:#668BA4;font-weight:bold;">call locations</span>
and not <span style="color:#668BA4;font-weight:bold;">animal
locations</span> as we’ve described previously. Call locations are
simply the location from which a call was made. The aSCR model
implemented and the interpretation of the density estimate is different
depending on which type of location we are modelling, and that is
determined by the <span
style="color:#668BA4;font-weight:bold;">detection unit</span> of our
study.</p>
<p>The detection unit is simply the thing we record as having been
detected. The detection unit is a call if we only record calls and not
the animal the call belongs to. If we detect some calls from identified
animals, the detection unit is the animals. Animals may further be
distinguished as individuals or groups of animals, so we could detect
calls coming from individuals or groups of animals.</p>
<p><img src="images/detflow1.png" width="100%" style="display: block; margin: auto;" /></p>
<p>The raw data that any acoustic survey collects are audio recordings
of the calls produced by the wildlife population. The recordings are
then typically processed via a computer program to isolate the calls of
the target species. For example, there is an open-source software
program called
<a href="http://www.pamguard.org/" target="_blank">PAMGAURD</a> that can
be used to identify calls of certain species. This cool technology was
first made for studying marine mammal sounds, but it has also been used
in many studies to identify the calls of the Cape Moss frog’s croaks.
Automated sound identification procedures, including complex machine
learning algorithms and statistical models, are complicated and varied.
These are not the focus of this tutorial, but if you’d like to know more
about detecting and classifying acoustic signals or just the use of
passive acoustics in ecological monitoring,
<a href="https://besjournals.onlinelibrary.wiley.com/doi/full/10.1111/2041-210X.13101" target="_blank">this</a>
is a cool paper to read.</p>
<p>The recording devices used in acoustic surveys typically also record
other information with audio recordings, called metadata. Two common
types of extra information are the strength of the received acoustic
signal (i.e. the call) and the time that the call was detected, referred
to as <span style="color:#668BA4;font-weight:bold;">signal
strength</span> and <span style="color:#668BA4;font-weight:bold;">time
of arrival</span> data, respectively. So each isolated call may have an
associated signal strength and/or arrival time attached to it. We can
include these measurements in our analysis to help our model estimate
the likely locations of detected calls and, consequently, improve
density estimates. We’ll explore this further in the next chapter.</p>
<div id="section-calling-density" class="section level3">
<h3>Calling Density</h3>
<p>At this point, the data can be analysed on the call level (i.e. with
a call as the detection unit) with an aSCR model that models call
locations. Consequently, our density estimate is <span
style="color:#668BA4;font-weight:bold;">calling density</span> - the
number of calls per unit area per unit time. We call this model aSCR-CD
for short, where CD stands for calling density.</p>
<p>If we want to convert calling density to animal density, we have to
know the average call rate of our target species. We could use the
average call rate from previous studies or independently collect data to
estimate the call rate ourselves.</p>
<p><img src="images/detflow2.png" width="100%" style="display: block; margin: auto;" /></p>
</div>
<div id="section-animal-or-group-density" class="section level3">
<h3>Animal (or Group) Density</h3>
<p>Identities of animals are never directly observed in acoustic surveys
- but if we can match detected calls to individual animals or groups of
animals, we can model animal or group locations and consequently,
estimate <span style="color:#668BA4;font-weight:bold;">animal or group
density</span> directly. Hence the model name, ascr-AD/GD. Our detection
unit is then an animal or a group of animals, depending on the nature of
the target species.</p>
<p>If you’re confused about the difference between call and animal
locations, this will help: in the aSCR-CD model, we assume that animals
move around between calls, so each call has a unique location. Under the
aSCR-AD/GD model, we assume that the detection units do not move between
calls which is another way of saying calls from one animal or group come
from the same location.</p>
<p>Data pre-processing starts as in aSCR-CD; we have to isolate the
species’ calls from the raw data. However, we have to somehow classify
calls as belonging to specific individuals or groups.</p>
<p><img src="images/detflow3.png" width="100%" style="display: block; margin: auto;" /></p>
<p>This particular aSCR model was developed relatively recently (in
2021), and presently, procedures to distinguish individual animals or
groups from acoustic data remain unattainable for most taxa. Even in
cases where it is feasible, accomplishing this task demands a lot of
hands-on work and may have considerable uncertainty attached to
individual identities. Similar to call identification, automated
procedures using machine learning techniques are likely to emerge in the
near future, and when they do, the aSCR-AD/GD model will be the way to
go for density estimation (unless calling density is of specific
interest).</p>
<p>Under the ASCR_AD/GD and ASCR-CD model, we assume that all
individuals or groups called at least once during the survey and either
detect those calls or not. Typically, there is no reason to think
otherwise, and we can implement a straightforward aSCR survey and the
aSCR-AD/GD model as is to estimate animal or group density.</p>
<p><img src="images/detflow4.png" width="100%" style="display: block; margin: auto;" /></p>
</div>
<div
id="section-animal-or-group-density-with-additional-data-collection"
class="section level3">
<h3>Animal (or Group) Density with additional data collection</h3>
<p>If, however, there are clear reasons why some would definitely not
have called even once during our survey occasion, we have to either
estimate an additional parameter (similar to the idea of estimating the
call rate in aSCR-CD) or adjust our survey structure.</p>
<p>For example, gibbons (Family Hylobatidae) occur in groups that engage
in duetted singing; not all groups will sing daily. The singing
frequency between and within groups may also differ due to
weather-related changes. Typically, a survey occasion is conducted for
two hours in the morning, so this assumption is violated because we know
not all groups sing in a single day. You might be thinking that why
could we not increase our survey length? Well, it is likely impossible
to increase it to such an extent that the assumption holds. In this
case, making the survey length a whole day would not solve the problem,
likely even two or three days either and then we could also likely be
violating the assumption of a closed population.</p>
<p>For species like this, we have to do a little bit more. We could
either stick with a single aSCR survey and then have to estimate
independently the proportion of times individuals or groups call. This
requires that human surveyors conduct focal follows of detected groups
or individuals over additional occasions to estimate the average
proportion of times the units vocalise. Alternatively, we can conduct
aSCR surveys on multiple occasions, which requires that individuals or
groups can be linked across occasions and that enough occasions are
chosen to ensure that each individual or group within the survey region
is likely to have called at least once. In Chapter 6, we will look at
these methods in more detail.</p>
<p><img src="images/detflow.png" width="100%" style="display: block; margin: auto;" /></p>
<p>Putting all of that together, we can see the three main workflows of
acoustic SCR determined by the type of detection unit and whether or not
we …</p>
<p>The upcoming chapters will cover these analyses. We’ll introduce the
R package we will use and implement a simple aSCR model for call
locations (aSCR-CD). Then we will look at ASCR-CD when additional
information is included in the analysis. Next, we’ll look into
implementing the acoustic SCR model (aSCR-AD/GD) when we have scaled our
data to the animal or group level and can directly estimate animal or
group density (AD/GD). Lastly, we look at the aSCR-AD/GD model when we
cannot assume that all individuals or groups will call during a single
survey.</p>
<div class="learnBox">
<p><strong>Summary:</strong></p>
<ul>
<li><p>Spatial capture-recapture models for acoustic data are known as
acoustic spatial capture-recapture or aSCR for short.</p></li>
<li><p>The detection unit of the survey determines the type of aSCR
model used and, thus, the type of density estimated.</p></li>
<li><p>When the detection unit is a call, we model call locations and
estimate calling density (aSCR-CD).</p></li>
<li><p>We model animal locations and estimate animal density (aSCR-AD)
when the detection unit is an animal.</p></li>
<li><p>When the detection unit is a group of animals, we model group
locations and estimate group density (aSCR-CD).</p></li>
<li><p>Regardless of the detection unit, the ultimate density estimate
is the density of calling animals or groups.</p></li>
<li><p>Recording devices can record additional information, such as
signal strength and time of arrival associated with the recorded
calls.</p></li>
<li><p>Under the aSCR-AD/GD model, we assume that all individuals or
groups will call during a single survey; if not we have to adjust our
survey structure accordingly.</p></li>
</ul>
</div>
</div>
</div>
<div id="section-ascr-cd" class="section level2">
<h2>ASCR-CD</h2>
<p>We’ll be working with real acoustic data collected a few years back
on a population of Cape Moss frogs. This data was gathered by Stevenson
et al. (2015), who also authored the paper that details the specific
aSCR-CD model we’ll be using. In their survey, they positioned six
microphones in a somewhat circular arrangement within the frogs’
habitat. We are using the same 25 second subset of the recording as in
the paper which was processed using the program PAMGUARD to identify
calls of the frog.</p>
<p>For those curious to visualize the setup, you can check out the
arrangement by following this link
<a href="https://www.youtube.com/watch?v=JTYFYtZJXro&t=56s" target="_blank">here</a>.
The video not only showcases the microphone configuration but also
offers a glimpse into the aSCR method. As you watch, you’ll be treated
to audio recordings of the Cape Moss frogs, along with a probable region
from which each call likely originated as estimated by an aSCR
model.</p>
<div id="section-introduction-to-textttacre" class="section level3">
<h3>Introduction to <span
class="math inline">\(\texttt{acre}\)</span></h3>
<p>We’re using a relatively new and slightly unfinished package called
<span class="math inline">\(\texttt{acre}\)</span> (named after the
method but also an acre is a unit of measurement). This package is
essentially a modernized and improved version of the initial aSCR R
package, named <span class="math inline">\(\texttt{ascr}\)</span>. The
<span class="math inline">\(\texttt{acre}\)</span> carries forward the
essentials of the previous one but also introduces the animal density
model and a range of other capabilities.</p>
<p>For those who have explored other SCR R packages, you’ll find the
structure of the <span class="math inline">\(\texttt{acre}\)</span>
package is familiar. Analysis using the <span
class="math inline">\(\texttt{acre}\)</span> package occurs in four
distinct phases: First, there’s the Pre-<span
class="math inline">\(\texttt{acre}\)</span> stage, where we prepare our
data. Then, we move to the process of <span
class="math inline">\(\texttt{acre}\)</span> formatting, combining our
data for further analysis. Following that, we get into the meat of
things — model fitting. In the last phase, inference, where we draw
meaningful conclusions from our fitted model.</p>
<p>So, in a nutshell, our journey through aSCR analysis involves these
four key phases: Pre-<span class="math inline">\(\texttt{acre}\)</span>,
<span class="math inline">\(\texttt{acre}\)</span> Formatting, Model
Fitting, and Inference. Each phase plays a critical role in unpacking
the insights hidden within our data.</p>
<p><img src="images/acre_workflow.png" width="100%" style=" display: block; margin: 1em auto;" /></p>
</div>
<div id="section-pre-textttacre" class="section level3">
<h3>Pre-<span class="math inline">\(\texttt{acre}\)</span></h3>
<p>The first phase requires modifying the data you have collected so
that it is in the required format for use in the <span
class="math inline">\(\texttt{acre}\)</span> package and creating a mask
object. Let’s go through each of these.</p>
<div id="section-captures" class="section level4">
<h4>Captures</h4>
<p>The captures dataframe contains our detections. The dataframe must
have at least 4 columns, where the first column is called “session”, the
second “ID”, third, “occasion” and the fourth column is “trap”. Each row
of the dataframe is considered a detection, meaning that each row is a
recorded call at a microphone. Our data is already in this format, let’s
have a look at it.</p>
<div class="tutorial-exercise" data-label="captures" data-completion="1"
data-diagnostics="1" data-startover="1" data-lines="0">
<pre class="text"><code>head(captures) # shows first six detections</code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":false,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
<div class="tutorial-exercise-support" data-label="captures-hint"
data-completion="1" data-diagnostics="1" data-startover="1"
data-lines="0">
<pre class="text"><code>tail(captures) # last six detections
summary(captures) # summary of dataframe
length(unique(captures$ID)) # number of unique calls detected</code></pre>
</div>
<p>You can play around with the dataframe if you want, use functions
like tail() to look at the last few detections or try to find out the
number of calls detected (see the hint for code).</p>
<p>The “ID” column contains unique identification numbers for all the
calls that were detected and the column “trap” contains the number of
the detector at which the call was recorded. For example, one call with
ID “1” was only detected at the second trap. Call “2” was detected at
traps three, four and five. Note that the calls aren’t labelled in the
order they were recorded, we’ve just used these labels for
simplicity.</p>
<p>Recall from Chapter 3 that one can have multiple survey occasions and
that typically, acoustic surveys only need one occasion. If we have
multiple survey occasions, the column “occasion” will indicate during
which occasion the detection was made. In a similar vein, the “session”
column indicates in which session the occasion occurred. We do not deal
with multiple sessions or occasions in this chapter, so both columns
consists entirely of 1s.</p>
<p>Depending on what your raw data looks like, there are several ways to
get to the required form. At the end of this Chapter there is an RScript
you can download which contains the full analysis we did here and also
some data preparation code for conversion from binary detection
histories to the required format.</p>
</div>
<div id="section-traps" class="section level4">
<h4>Traps</h4>
<p>The second object, traps, can either be a list, matrix or dataframe
and in the context of aSCR, traps refer to the recording devices.</p>
<p>If we had multiple sessions then we would have a list of dataframes
or matrices, each containing the Cartesian coordinates of the detector
locations. Since we are only working with a single survey occasion, we
do not have to worry about the list version of traps right now. For our
analysis, the object will be either in matrix or dataframe format.
Either way, the object should consists of two columns representing the x
and y Cartesian coordinates of our detector locations. Below, we again
look at the first six rows and then plot the detector locations.</p>
<div class="tutorial-exercise" data-label="traps" data-completion="1"
data-diagnostics="1" data-startover="1" data-lines="0">
<pre class="text"><code>head(traps)

# plot trap locations

ggplot(traps, aes(x = x, y = y)) +
  geom_point() +
  coord_fixed() +
  xlim(-5, 10) +
  ylim(-5, 10) </code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":false,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
<p>We are using the package ggplot to visualize our data. We supply the
dataframe to ggplot() and then we tell it what to plot on the x and y
axes within the brackets of <span
class="math inline">\(\texttt{aes()}\)</span>, here it is simply the
names of the columns of the traps dataframe, ‘x’ and ‘y’. Then we
specify that we want a scatterplot with <span
class="math inline">\(\texttt{geom_point()}\)</span>, i.e. we want a
plot of points and we specify the limits of the axes with <span
class="math inline">\(\texttt{xlim()}\)</span> and <span
class="math inline">\(\texttt{ylim()}\)</span>. We’ve changed the x and
y limits on the axes so you can see the arrangement clearly. Adding all
these things together with a plus sign (note that this notation only
works for ggplot code) plots the data.</p>
</div>
<div id="section-mask-1" class="section level4">
<h4>Mask</h4>
<p>The third thing we have to supply is the habitat mask. We create a
mask with the function <span
class="math inline">\(\texttt{create.mask()}\)</span> which requires, at
minimum, the traps dataframe and a buffer distance.</p>
</div>
<div id="section-quick-diversion-on-the-buffer-distance"
class="section level4">
<h4>Quick diversion on the buffer distance</h4>
<p>SCR theory has shown that the buffer distance isn’t super crucial as
long as it is sufficiently wide to ensure that animals located at the
periphery have an extremely low probability of being detected.</p>
<p>A rule of thumb when using a halfnormal detection function is four
times its “shoulder parameter”, <span
class="math inline">\(\sigma_{hn}\)</span>. We can get a quick and
biased estimate of <span class="math inline">\(\sigma_{hn}\)</span> from
our data using the function <span
class="math inline">\(\texttt{RPSV()}\)</span> from the <span
class="math inline">\(\texttt{secr}\)</span> package and multiply it
with four to get a buffer distance.</p>
<p>An alternative way is using the function <span
class="math inline">\(\texttt{suggest.buffer()}\)</span>, also from
<span class="math inline">\(\texttt{secr}\)</span>. This function as its
name implies, provides a mere <strong>suggestion</strong> of buffer
distance based our detection data and traps. The methodology behind the
function is not well documented and we’re not going to try and explain
it here, but we can use this function to get a suitable buffer distance
and then check after model fitting whether the distance was wide
enough.</p>
<p>To do either of the two methods, we have to convert our data to the
<span class="math inline">\(\texttt{secr}\)</span> format. First we add
a column to the traps dataframe called “trap” that contains the trap
identification number. Then we create a <span
class="math inline">\(\texttt{secr}\)</span> traps object with the
function <span class="math inline">\(\texttt{read.traps()}\)</span>
where we supply the traps dataframe, tell the function which column
contains the trap identification numbers and also what type of detectors
were used. Recall from Chapter 3 that recording devices and any other
detector that does not physically detain animals, are proximity
detectors.</p>
<p>Then we create a <span class="math inline">\(\texttt{secr}\)</span>
capture history object with the captures dataframe, the <span
class="math inline">\(\texttt{secr}\)</span> traps object and we specify
the format we have used for the captures dataframe. The options are
“trapID” and “XY”, where the first option indicates that the last column
in the captures dataframe contains the trap identification number where
each detection was made (like we have - session, ID, occasion, traps).
The other format is if we have the x nd y coordinates of the trap
location instead of the number (session, ID, occasion, x, y).</p>
<div class="tutorial-exercise" data-label="buffer" data-completion="1"
data-diagnostics="1" data-startover="1" data-lines="0">
<pre class="text"><code># trap dataframe
traps$trap &lt;- rownames(traps) # add trap column with trap ids

secr_traps &lt;- read.traps(
  data = traps, # trap layout data
  trapID = &quot;trap&quot;, # name of ID column
  detector = &quot;proximity&quot;
) # detector type

secr_capthist &lt;- make.capthist(
  captures = captures, # captures
  traps = secr_traps, # traps
  fmt = &quot;trapID&quot;
) # format of captures

# quick and biased sigma
initialsigma &lt;- RPSV(
  capthist = secr_capthist,
  CC = TRUE
)

round(4 * initialsigma) # suggested buffer distance

# using suggest.buffer()

suggest.buffer(object = secr_capthist, detectfn = &quot;HN&quot;)</code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":false,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
<p>Back to the mask! Below we’ve created a simple mask with specified
the suggested buffer distance of 14 metres. We visualize the mask and
detectors together with ggplot. Inspect the mask object further, is it a
dataframe or a matrix?</p>
<div class="tutorial-exercise" data-label="mask" data-completion="1"
data-diagnostics="1" data-startover="1" data-lines="0">
<pre class="text"><code># create mask
mask &lt;- create.mask(lightfooti_traps, buffer = 10)

# inspect mask object
head(mask)

ggplot() +
  geom_point(data = as.data.frame(mask), aes(x = x, y = y, color = &quot;Mask&quot;), alpha = 0.2) +
  geom_point(data = traps, aes(x = x, y = y, color = &quot;Detector&quot;)) +
  scale_color_manual(values = c(&quot;Mask&quot; = &quot;darkgrey&quot;, &quot;Detector&quot; = &quot;blue&quot;)) +
  labs(title = &quot;Habitat mask &amp; microphones&quot;, x = &quot;X&quot;, y = &quot;Y&quot;) +
  theme(legend.title = element_blank())</code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":false,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
<div class="tutorial-exercise-support" data-label="mask-hint"
data-completion="1" data-diagnostics="1" data-startover="1"
data-lines="0">
<pre class="text"><code># inspect object
class(mask)
str(mask)

# help files
?create.mask()
?make.mask()</code></pre>
</div>
<p>We can also modify our mask by specifying the spacing between mask
points with the argument <strong>spacing</strong> and we can exclude
certain mask points that represent non-suitable habitat using the
<strong>poly</strong> arguments. Have a look at the help file for the
function which will point you toward the function <span
class="math inline">\(\texttt{make.mask()}\)</span> from the <span
class="math inline">\(\texttt{secr}\)</span> package.</p>
<p>If you’ve inspected the object, you would have seen that the created
mask object is a matrix, we have to convert it to a dataframe if we want
to plot it with ggplot. The code is slightly more complicated than the
previous plot, we’ve colour coded the points using the arguments
<strong>color</strong> in the aes functions of each geom_point and we’ve
assigned a color to each using the <span
class="math inline">\(\texttt{scale_color_manual()}\)</span> function.
Lastly, a title is added and the legend title is removed.</p>
</div>
</div>
<div id="section-textttacre-formatting" class="section level3">
<h3><span class="math inline">\(\texttt{acre}\)</span> formatting</h3>
<p>In the next phase, <span class="math inline">\(\texttt{acre}\)</span>
formatting, we supply all the objects from the first phase to a key
function of the package called <span
class="math inline">\(\texttt{read.acre()}\)</span>. This function
creates an object of class “acre_data” and essentially links together
our detectors and detection data. Any other data objects we need for
model fitting is also included here.</p>
<p>The first three arguments of this function are the three objects we
created in the previous phase. If we have any habitat covariates we want
to include in our density model, we also supply it here in the argument
<strong>loc_cov</strong>. The argument takes a dataframe consisting of
at least three columns, the first two are x and y coordinates of where
the habitat covariates have been measured and the remaining columns
contain the covariate values. For example:</p>
<div class="tutorial-exercise" data-label="examp_loc"
data-completion="1" data-diagnostics="1" data-startover="1"
data-lines="0">
<pre class="text"><code>example_loc_data &lt;- data.frame(
  x = c(-20, -20, -20, 2.5, 2.5, 2.5, 25, 25, 25),
  y = c(-20, 5, 30, -20, 5, 30, -20, 5, 30),
  noise = c(6, 10, 11, 7, 12, 10, 11, 9, 8),
  forest_vol = c(&quot;high&quot;, &quot;high&quot;, &quot;median&quot;, &quot;median&quot;, &quot;median&quot;, &quot;low&quot;, &quot;low&quot;, &quot;low&quot;, &quot;low&quot;)
)

head(example_loc_data)</code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":false,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
<p>Remember we mentioned in Chapter 3 that we typically don’t have
covariate values for every mask point and that given a few measured
locations (like in the dataframe above), we can impute the rest. This
will happen in the model fitting phase, the habitat covariates will be
scaled to the mask level, i.e. every mask point will have an associated
covariate value (more on this below).</p>
<p>However, if we don’t have any habitat covariates but we do want to
model density with a spatial trend (i.e. as a function of the x and/or y
coordinates of our mask points) we have to do the following. You can
include a random subset of x and y coordinates pairs (like the example
above) or all the mask points, but because the function expects a
dataframe with more than two columns, we add a random column that won’t
be used.</p>
<p>Below we create a dataframe called “cov_data” that contains the
coordinates of all the mask points and a random column called spat_trend
where every entry is just “yes”. It really doesn’t matter what this
column is, we just need a third column. We then supply the dataframe
together with the captures, traps and mask object to the <span
class="math inline">\(\texttt{read.acre()}\)</span> function.</p>
<div class="tutorial-exercise" data-label="cov_dat" data-completion="1"
data-diagnostics="1" data-startover="1" data-lines="0">
<pre class="text"><code>cov_dat &lt;- data.frame(x = mask[, 1], y = mask[, 2], spat_trend = &quot;yes&quot;)

lightfooti_data &lt;- read.acre(
  captures = captures,
  traps = traps,
  mask = mask,
  loc_cov = cov_dat
)

# alternative mask creation

# lightfooti_data &lt;- read.acre(
#   captures = captures,
#   traps = traps,
#   control_create_mask = list(buffer=10),
#   loc_cov = cov_dat
# )</code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":false,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
<p>The commented lines of code show the second way in which we could
have created the mask. Instead of using the argument mask, we supply the
arguments of the <span
class="math inline">\(\texttt{create.mask()}\)</span> function as a list
to the argument <strong>control_create_mask</strong>.</p>
<p>Some other arguments and important points:</p>
<ul>
<li><p>The default units for the <span
class="math inline">\(\texttt{acre}\)</span> package is metres and
seconds. If our data are not in metres and seconds, we can specify in
the <strong>units_convert_dist</strong> and
<strong>units_convert_time</strong> arguments the number needed to
convert from whatever our data is in to meters. For example, if our data
is in minutes, then we assign the value 60 to the argument
<strong>units_convert_time.</strong> Likewise, if our data are in cm for
some reason then we assign the value 0.01 to
<strong>units_convert_dist</strong>.</p></li>
<li><p>If we have reason to believe that there are other factors that
influence the detection probabilities of individual detectors, we can
supply a dataframe containing the trap specific information to the
argument <strong>trap_cov.</strong></p></li>
<li><p>Similarly, if we had multiple sessions and we have quantified
some information about the different session that might influence our
model estimates, then we can supply this data to the argument
<strong>session_cov</strong>.</p></li>
<li><p>Typically we don’t have covariate data for every point in our
habitat mask but rather only a few select points in the survey region.
We can use the information we have to impute data for the rest of the
mask. The <span class="math inline">\(\texttt{read.acre()}\)</span>
function does this for us using a machine learning algorithm called
Approximate Near Neighbor. Essentially, this method calculates the
likely value of each mask point based on the values of a specified
number of nearest points with measured covariate values. We can modify
some of the parameters of this method if we want, but this is beyond the
scope of this tutorial (have a look at the function help file for more
details).</p></li>
</ul>
</div>
<div id="section-model-fitting" class="section level3">
<h3>Model fitting</h3>
<p>Finally, we are ready to fit some aSCR models! We have gone through
the first two phases, getting our data objects ready and putting them
all together with the <span
class="math inline">\(\texttt{read.acre()}\)</span> function. Now, we
use the key function, <span
class="math inline">\(\texttt{fit.acre()}\)</span>, to fit the aSCR
model.</p>
<p>The first argument of the function (<strong>dat</strong>) is the
acre_data object we created with the <span
class="math inline">\(\texttt{read.acre()}\)</span> function. Then, we
tell the model what our density model is with the
<strong>par_extend_model</strong> argument. The default is to assume
constant density which is specified as “D~1”. The notation reads as
Density (D) is (=) a function of (~) whatever comes next. The model
formulas for the examples we looked in Chapter 3 were specified as
follows (plus some other trends):</p>
<ul>
<li><p>East-west trend: D = ~ x</p></li>
<li><p>North-south trend: D = ~ y</p></li>
<li><p>Linear trend: D = ~ x + y</p></li>
<li><p>Quadratic trend: D = ~ x^2 + x*y + y^2</p></li>
<li><p>Density as a function of noise: D = ~ noise</p></li>
<li><p>Density as a function of noise: D = ~ forest_vol</p></li>
</ul>
<p>In the above, x and y, are the mask points and “noise” and
“forest_vol” are the habitat covariates which should correspond to the
column names used in the dataframe assigned to the
<strong>loc_cov</strong> argument of the <span
class="math inline">\(\texttt{read.acre()}\)</span> function.</p>
<p>Then, we tell the function which type of detection function to fit to
the data in the <strong>detfn</strong> argument. For example, if we
specify the halfnormal detection function, we assign the character
string “hn” to argument. There are other arguments which we have not
covered here. These are all optional arguments and the ones we have
presented are required for model fitting. Let’s fit a simple model using
the objects we have created so far.</p>
<p>Below we fit a constant density model and a halfnormal detection
function to the frog data and call the model, “model1”. We don’t have to
specify the density model in the <strong>par_extend_model</strong>
argument as we are using the default model. The detection function
parameter, <span class="math inline">\(g0\)</span>, is fixed at one,
since we expect that all calls made exactly at the detector locations
will be recorded. Straightforward and easy right?</p>
<div class="tutorial-exercise" data-label="model1" data-completion="1"
data-diagnostics="1" data-startover="1" data-lines="0">
<pre class="text"><code>model1 &lt;- fit.acre(
  dat = lightf_data,
  detfn = &quot;hn&quot;,
  fix = list(g0=1)
)</code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":false,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
</div>
<div id="section-inference" class="section level3">
<h3>Inference</h3>
<p>Now that we have fitting some models, we can look at the model
estimates. Extracting information from our model object is not different
from any other model objects you might have used before. We’ll begin
with model1. We can use the <span
class="math inline">\(\texttt{summary()}\)</span> function the look at a
summary of our model estimates:</p>
<div class="tutorial-exercise" data-label="inf1" data-completion="1"
data-diagnostics="1" data-startover="1" data-lines="0">
<pre class="text"><code>summary(model1)</code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":false,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
<p>The output tell us the detection function used to fit the model, the
number of sessions, whether or not extra information was inputted into
the model and the method use for constructing confidence intervals of
our estimates. Below that we get a neat table of our model estimates and
associate variance estimates.</p>
<p>For each parameter of our model, we obtain an estimate, a <span
style="color:#668BA4;font-weight:bold;">standard error</span>, and two
additional values under the columns labeled “2.5%” and “97.5%.” These
values define a <span style="color:#668BA4;font-weight:bold;">confidence
interval</span> for our estimate. While we assume you have some
familiarity with these concepts, we offer a brief explanation here.
Alternatively, if you need more information, you can refer back to the
welcome page where we provide additional resources.</p>
<p>Quantifying the uncertainty of our model estimates is crucial. When
conducting a survey, we collect a sample to estimate population-level
parameters (e.g., density). However, due to random differences between
samples, our estimates will vary from one sample to another. The
standard error serves as a measure of the variability or precision of an
estimate. It tells us how much the estimated parameter is expected to
differ across different samples. Smaller standard errors are preferable,
as they indicate less variability and increased precision.</p>
<p>A confidence interval is a range of values calculated from the sample
data that surrounds a single estimate. This interval provides a range
where the true population parameter is likely to fall under repeated
sampling. For instance, a 95% confidence interval for a mean suggests
that if you were to repeatedly draw samples from the same population and
compute confidence intervals each time, the true population mean would
likely be within that interval about 95% of the time. In simpler terms,
we can express 95% confidence that the interval contains the true mean.
A narrower interval is better, just like a smaller standard error, as it
reflects reduced variability and greater precision.</p>
<p>The following bit is really important. In the aSCR-CD model, these
values are not reliable. Understanding the underlying statistical and
mathematical concepts is necessary to grasp the reason behind this
limitation, and we have intentionally avoided delving into these
complexities. If you’re interested in learning more, we recommend
reading the paper by
<a href="https://besjournals.onlinelibrary.wiley.com/doi/full/10.1111/2041-210X.12291" target="_blank">Stevenson
et al. (2015)</a> for a comprehensive explanation of the model
formulation and assumptions. However, for the purposes of this tutorial,
what’s important to know is that we cannot trust the estimates of
standard errors and confidence intervals derived from fitting an aSCR-CD
model.</p>
<p>To obtain appropriate standard errors and confidence intervals, we
need to use a different function. The <span
class="math inline">\(\texttt{boot.acre()}\)</span> function employs a
technique called “bootstrapping” to calculate standard errors and
confidence intervals of our estimates that can be reliably reported. In
this process, we simulate a synthetic population using our model and
generate samples (detect calls) from this population using the estimated
detection function. We then fit the same model to this simulated data
and record the model estimates. This procedure is repeated numerous
times, allowing us to compute the standard error and establish
confidence intervals as we’ve essentially done the repeated sampling!
Bootstrapping is an extremely useful statistical method, here is a fun
video explaining the method further if you want to know more.</p>
<p>The number of times we perform this procedure (controlled by the
argument N) ideally exceeds 100 repetitions, and in practice we would
likely opt for more iterations, such as around 1000. This can take super
long to run, so we’ve already done it and saved the output as
model1_boot. However, if you’re interested, you can carry out this
procedure for a smaller N value, say 10. Alternatively, explore the
structure of the model1_boot object using the <span
class="math inline">\(\texttt{str()}\)</span> function or by typing the
object name followed by a dollar sign ($) to examine its contents.</p>
<div class="tutorial-exercise" data-label="boot" data-completion="1"
data-diagnostics="1" data-startover="1" data-lines="0">
<pre class="text"><code># boot_N10 &lt;- boot.acre(model1, N = 10)

str(model1_boot)</code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":false,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
<div class="tutorial-exercise-support" data-label="boot-hint"
data-completion="1" data-diagnostics="1" data-startover="1"
data-lines="0">
<pre class="text"><code>model1_boot$ </code></pre>
</div>
<p>There is a lot going on here! Luckily for us, we don’t have to delve
into all of these. To obtain the standard errors, we simply apply the
function, <span class="math inline">\(\texttt{stdEr()}\)</span>, to our
bootstrap object. To make sure we are using the function from the
correct package, we use the following notation <span
class="math inline">\(\texttt{acre::stdEr()}\)</span>.</p>
<p>We extract the confidence intervals using the function <span
class="math inline">\(\texttt{confint()}\)</span> and specify the
argument <strong>type</strong> as “fitted” to ensure our confidence
intervals are on the same scale as our estimates. Why we have to do this
will become clear later.</p>
<div class="tutorial-exercise" data-label="stder" data-completion="1"
data-diagnostics="1" data-startover="1" data-lines="0">
<pre class="text"><code>acre::stdEr(model1_boot)

confint(model1_boot, type=&quot;fitted&quot;)</code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":false,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
<p>Viola! We now have appropriate standard errors and confidence
intervals. Let’s go back to the model output. The parameters of the
detection function, <span class="math inline">\(\sigma\)</span> and
<span class="math inline">\(g0\)</span> were estimated to be roughly
5.92 and 1, respectively. We fixed <span
class="math inline">\(g0\)</span> at one, so that’s to be expected. We
can use the function <span
class="math inline">\(\texttt{show_detfn()}\)</span> directly with our
model object to plot the estimated detection function.</p>
<div class="tutorial-exercise" data-label="inf3" data-completion="1"
data-diagnostics="1" data-startover="1" data-lines="0">
<pre class="text"><code>summary(model1)

show_detfn(model1)</code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":false,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
<p>A similar function, <span
class="math inline">\(\texttt{show_Dsurf()}\)</span>, will plot the
estimated calling density surface in number of animals per hectare - try
it out. It’s not very informative as we’ve specified constant calling
density, so density remains the same across our survey region.</p>
<div class="tutorial-exercise-support" data-label="inf3-hint"
data-completion="1" data-diagnostics="1" data-startover="1"
data-lines="0">
<pre class="text"><code>show_Dsurf(model1)</code></pre>
</div>
<p>Remember the estimate of density we get here is calling density - the
number of calls per metre squared per second. In our model, average
calling density was estimated to be approximately 3607 calls per metre
squared per second. That’s a lot of calls!</p>
<p>If we want to convert calling density to animal density, we need to
know the call rate of the species. We can use estimates of the average
call rate from previous studies or we can collect independent data to
estimate it ourselves. For the latter, you’d have to monitor a different
sample of frogs separately from the main aSCR survey to collect several
call rate estimates and take the average of those.</p>
<p>For the frog data, the authors collected eight such samples and
calculated the call rate for each sample. The call rate is taken as the
number of calls made per second. To obtain an estimate of animal
density, we divide the estimated calling density of 3607 with the
average of all the calculated call rates.</p>
<p>In the code below, we use the dollar sign notation to extract a
numeric vector containing all the parameter estimates. You can ignore
the estimates with suffixed with “_link” for now. The density estimate
is the fifth element and we extract it to calculate animal density.</p>
<div class="tutorial-exercise" data-label="inf4" data-completion="1"
data-diagnostics="1" data-startover="1" data-lines="0">
<pre class="text"><code># call rates
call_rates 

# model contents 
model1$coefficients

# animal density
(D_animal &lt;- model1$coefficients[5] / mean(call_rates))  

# convert to per hectare 
D_animal/10000 </code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":false,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
<p>We estimated roughly 532682 frogs per metre squared throughout our
survey region, quite a big number! Remember these frogs are super super
tiny so this number is too crazy. To make it a bit more digestible, we
can convert to per hectare by dividing with 100000 to get 53 frogs per
hectare.</p>
</div>
<div id="section-exercise-non-constant-density" class="section level3">
<h3>Exercise: Non-constant density</h3>
<p>Let’s also fit a model with a spatial trend in density.</p>
<p>First, we’re going to create a new acre_data object which includes
the call rates we used previously. By doing this, our model will
automatically convert our calling density estimates to animal density.
We could have done this for model1 as well, but we thought it would be
good to understand first how the calling density is converted to animal
density.</p>
<div class="tutorial-exercise" data-label="acre_data2"
data-completion="1" data-diagnostics="1" data-startover="1"
data-lines="0">
<pre class="text"><code>lightfooti_data2 &lt;- read.acre(
  captures = captures,
  traps = traps,
  mask = mask,
  loc_cov = cov_dat,
  cue.rates = call_rates
)</code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":false,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
<p>Below we fit the model with a spatial trend in density. The only new
thing is the <strong>par_extend_argument</strong> which requires that
you put the density model in a list.</p>
<div class="tutorial-exercise" data-label="model2" data-completion="1"
data-diagnostics="1" data-startover="1" data-lines="0">
<pre class="text"><code>model2 &lt;- fit.acre(
  dat = lightfooti_data2,
  detfn = &quot;hn&quot;, 
  par_extend_model = list(D=~x),
  fix = list(g0 = 1)
)</code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":false,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
<p>Note, we’ve fitted this model purely for demonstrative purposes.
There is no real justification for specifying an east to west trend.</p>
<p>Do the same post model fitting analysis (i.e. inference) for model2
with the spatial trend.</p>
<p>Tasks:</p>
<ol style="list-style-type: decimal">
<li>Look at the model summary and plot the detection function.</li>
</ol>
<div class="tutorial-exercise" data-label="exercise1"
data-completion="1" data-diagnostics="1" data-startover="1"
data-lines="0">
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":false,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
<div class="tutorial-exercise-support" data-label="exercise1-solution"
data-completion="1" data-diagnostics="1" data-startover="1"
data-lines="0">
<pre class="text"><code>summary(model2)
show_detfn(model2)</code></pre>
</div>
<p>You’ll likely have noticed that the model output is a bit different.
The detection function parameters remain the same as expected (we
haven’t changed anything). We have two parameters relating to density:
“D.(Intercept)” and “D.x”. These are the parameters we briefly mentioned
in Chapter 3 when we looked at the different density models.</p>
<p>When we include habitat or spatial covariates in our density model,
<span class="math inline">\(\texttt{fit.acre()}\)</span> automatically
models density as a function of these variable using a generalised
linear model. If you’d like to know more about this statistical method
which is super straightforward and easy to understand, have a look at
the resources in the welcome page. For now, all you need to know is that
the intercept parameter represents the average calling density when the
habitat covariate is zero, i.e. when the x coordinate is equal to zero.
Whether or not this is useful information depends on the habitat
covariate, here it’s not very informative. The default for the
regression model, is to use the so-called log link function. In other
words, the log of calling density is modelled as a function of the
covariates. We can convert the parameters back to its normal scale, by
exponentiating the parameter values.</p>
<div class="tutorial-exercise" data-label="backtrans"
data-completion="1" data-diagnostics="1" data-startover="1"
data-lines="0">
<pre class="text"><code>exp(model2$coefficients[5]) # intercept 
exp(model2$coefficients[6]) # effect </code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":false,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
<p>The intercept parameter is pretty much the same as the animal density
we calculated using model1. This is expected as the intercept is the
average density across our survey region when the covariate has no
influence, just like when assuming a constant density model.</p>
<p>The second parameter, “D.x”, is the expected change in animal density
per one unit increase in the habitat covariate. Our model estimated
that, on average, animal density increased by roughly 1 frog per square
metre per second for every one metre increase in the x direction.</p>
<ol start="2" style="list-style-type: decimal">
<li>Obtain appropriate variance estimates using the bootstrap procedure
using N = 10 and save the output as “model2_boot”.</li>
</ol>
<div class="tutorial-exercise" data-label="exercise2"
data-completion="1" data-diagnostics="1" data-startover="1"
data-lines="0">
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":false,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
<div class="tutorial-exercise-support" data-label="exercise2-solution"
data-completion="1" data-diagnostics="1" data-startover="1"
data-lines="0">
<pre class="text"><code>model2_boot &lt;- boot.acre(model2, N = 10) 

acre::stdEr(model2_boot)

confint(model2_boot)</code></pre>
</div>
<ol start="3" style="list-style-type: decimal">
<li>Plot the estimated calling density surface. The default when we’ve
included call rates in our acre_data object is to plot animal density
per sqaure metre, use the argument <strong>scale</strong> with the value
0.0001 to convert to per hectare.</li>
</ol>
<div class="tutorial-exercise" data-label="exercise3"
data-completion="1" data-diagnostics="1" data-startover="1"
data-lines="0">
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":false,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
<div class="tutorial-exercise-support" data-label="exercise3-solution"
data-completion="1" data-diagnostics="1" data-startover="1"
data-lines="0">
<pre class="text"><code>show_Dsurf(model2, scale = 0.0001) # per hectare </code></pre>
</div>
<p>Nice! Our density surface is reflecting the spatial trend we
specified. The model estimated that animal density increases from east
to west. This increase seems slight which corresponds to the small
effect of an increase of 1 animal per square metre.</p>
<p><strong>A possibly big note of caution: </strong></p>
<p>When fitting aSCR-CD models, meaning we are modelling calling
locations, fitting a non-constant density model may be misleading. Areas
where many calls are estimated to come from could be due to two things:
there could be a lot of animals calling but there are also could be a
few individuals making a lot of calls. So when converting from calling
density to animal density, areas of high animal density could possibly
be due to a small number of acoustically active individuals.</p>
<div class="learnBox">
<p><strong>Summary:</strong></p>
<ul>
<li><p>Analysis using the <span
class="math inline">\(\texttt{acre}\)</span> package has four phases:
pre-<span class="math inline">\(\texttt{acre}\)</span>, <span
class="math inline">\(\texttt{acre}\)</span>-formatting, model fitting
and inference.</p></li>
<li><p>Make sure all the distance and time related objects are in metres
and seconds or provide the values necessary for conversion in the <span
class="math inline">\(\texttt{acre}\)</span>-formatting phase.</p></li>
<li><p>In the first phase we create three objects: captures dataframe
with four columns (session, ID, occasion and trap), a traps dataframe
containg the coordinates of our detector locations and a habitat
mask.</p></li>
<li><p>Then we combined these objects into an “acre_data” object with
the function <span class="math inline">\(\texttt{read.acre()}\)</span>
in the second phase.</p></li>
<li><p>Model fitting uses the function <span
class="math inline">\(\texttt{fit.acre()}\)</span> which requires the
acre_data object, the specified detection function and we also specify
the density model.</p></li>
<li><p>After model fitting, we look at the estimates, the detection
function and density surface in the last phase.</p></li>
<li><p>When the detection unit is a call, the variance estimates we get
after model fitting are not reliable so we have to use bootstrapping to
obtain reliable standard errors and confidence intervals.</p></li>
<li><p>We can get a suggested buffer distance when using a halfnormal
function with the <span
class="math inline">\(\texttt{suggest.buffer()}\)</span> function from
the package <span class="math inline">\(\texttt{secr}\)</span>.</p></li>
</ul>
</div>
<p><br/></p>
<a href="data:text/plain;base64,IyBBQ1JFOiBMSUdIVEZPT1RJIFNJTkdMRSBTVVJWRVkgQU5BTFlTSVMKbGlicmFyeShsZWFybnIpCmxpYnJhcnkoYWNyZSkKbGlicmFyeShhc2NyKQpsaWJyYXJ5KHRpZHl2ZXJzZSkKbGlicmFyeShzZWNyKQoKIyBEYXRhIHByZXBhcmF0aW9uIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KCiMgZ2V0IGRhdGEgZnJvbSBhc2NyIHBhY2thZ2UgCmxpZ2h0Zm9vdGlfZGF0YTwtYXNjcjo6bGlnaHRmb290aQoKIyBDb252ZXJ0IGJpbmFyeSBjYXB0dXJlIGhpc3RvcnkgZGF0YSB0byBmb3JtYXQgcmVxdWlyZWQgZm9yIGRhdGEgZnVuY3Rpb24gCgpjYXB0X3NpbmdsZSA8LSBsaWdodGZvb3RpX2RhdGEkY2FwdCRiaW5jYXB0CgojIE1FVEhPRCAxIC0gRk9SIExPT1BTCgojICMgYWRkIGlkcyBhcyByb3duYW1lcyAKIyBmaXJzdF9zdXJ2ZXlfaWRzIDwtIGlkcy5ib3RoW1sxXV0KIyByb3duYW1lcyhjYXB0X3NpbmdsZSkgPC0gZmlyc3Rfc3VydmV5X2lkcwoKIyBDcmVhdGUgZW1wdHkgdmVjdG9ycyB0byBzdG9yZSByZXN1bHRzCnRyYXBzX0lEPC0gYygpCklEIDwtIGMoKQoKZm9yIChpIGluIDE6bnJvdyhjYXB0X3NpbmdsZSkpIHsKICBmb3IgKGogaW4gMTpuY29sKGNhcHRfc2luZ2xlKSkgewogICAgaWYgKGNhcHRfc2luZ2xlW2ksIGpdID09IDEpIHsKICAgICAgdHJhcHNfSUQgPC0gYyh0cmFwc19JRCwgaikKICAgICAgSUQgPC0gYyhJRCwgcm93bmFtZXMoY2FwdF9zaW5nbGUpW2ldKQogICAgfQogIH0KfQoKIyBDcmVhdGUgYSBkYXRhZnJhbWUgd2l0aCB0aGUgcmVzdWx0cwpjYXB0dXJlcyA8LSBkYXRhLmZyYW1lKElELCB0cmFwcyA9IHRyYXBzX0lEKQpucm93KGNhcHR1cmVzKQoKIyBhZGQgc2Vzc2lvbiBhbmQgb2NjYXNpb24gY29sdW1ucyAKY2FwdHVyZXMkc2Vzc2lvbiA8LSAxCmNhcHR1cmVzJG9jY2FzaW9uIDwtIDEgCgojIHJlb3JkZXIgCmNvbF9vcmRlciA8LSBjKCJzZXNzaW9uIiwiSUQiLCJvY2Nhc2lvbiIsInRyYXBzIikKY2FwdHVyZXMgPC0gY2FwdHVyZXNbLGNvbF9vcmRlcl0KCiMgTUVUSE9EIDIgLSBOTyBGT1IgTE9PUFMgCgojIENyZWF0ZSBhIG1hdHJpeCBvZiByb3cgYW5kIGNvbHVtbiBpbmRpY2VzIHdoZXJlIGNhcHQgPT0gMQppbmRpY2VzIDwtIHdoaWNoKGxpZ2h0Zm9vdGlfZGF0YSRjYXB0JGJpbmNhcHQgPT0gMSwgYXJyLmluZCA9IFRSVUUpCgojIEV4dHJhY3QgdGhlIHJvdyBhbmQgY29sdW1uIGluZGljZXMKSUQgPC0gaW5kaWNlc1ssIDFdCnRyYXBzX0lEIDwtIGluZGljZXNbLCAyXQoKIyBDcmVhdGUgYSBkYXRhZnJhbWUgd2l0aCB0aGUgcmVzdWx0cwpjYXB0dXJlcyA8LSBkYXRhLmZyYW1lKElELCB0cmFwID0gdHJhcHNfSUQpICU+JQogIGFycmFuZ2UoSUQpCgojIGFkZCBzZXNzaW9uIGFuZCBvY2Nhc2lvbiBjb2x1bW5zCiMgcmVwbGFjZSByb3duYW1lcyBpbiBJRCB3aXRoIGlkcyAKCmNhcHR1cmVzIDwtIGNhcHR1cmVzICU+JQogIG11dGF0ZShzZXNzaW9uID0gMSwgb2NjYXNpb24gPSAxKSAlPiUKICBzZWxlY3Qoc2Vzc2lvbixJRCxvY2Nhc2lvbix0cmFwKQoKIyBzb21lIEVEQSAKbGVuZ3RoKHVuaXF1ZShjYXB0dXJlcyRJRCkpICMgMjI1IENBTExTIAoKIyB0cmFwIGRhdGFmcmFtZSBmb3IgdHV0b3JpYWwKdHJhcHMgPC0gYXMuZGF0YS5mcmFtZShsaWdodGZvb3RpJHRyYXBzKQoKIyBJbnRyb2R1Y3Rpb24gdG8gcGFja2FnZSBhY3JlIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCgojIyMgUmVhZCBkYXRhIGZ1bmN0aW9uIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KCiMgbG9vayBhdCBmdW5jdGlvbiBoZWxwIGZpbGUgCj9yZWFkLmFjcmUoKQoKIyAxc3QgYW5kIHNlY29uZCBhcmd1bWVudHMgc2hvdWxkIGJlIGRhdGFmcmFtZXMgdGhhdCBhcmUgcGFzc2VkIHRvIHRoZSBmdW5jdGlvbiAKIyBjcmVhdGUuY2FwdCgpCj9jcmVhdGUuY2FwdAoKIyBjYXB0dXJlcyBtdXN0IGJlIGEgZGF0YWZyYW1lcyB3aXRoIGF0IGxlYXN0IDQgY29sdW1uczogY29sIDEgLT4gc2Vzc2lvbiwgY29sIDIgLT4gSUQgCiMgY29sIDQtPiB0cmFwc19JRCAKCmNhcHR1cmVzCgojIHRyYXBzIC0+IG1hdHJpeCwgbGlzdCBvciBkYXRhZnJhbWUgLT4gdHdvIGNvbHVtbnMgeCBhbmQgeSBjYXJ0ZXNpYW4gY29vcmRpbmF0ZXMKIyBvZiB0cmFwIGxvY2F0aW9ucyAKCnRyYXBzCgpkaW0odHJhcHMpICMgc2l4IG1pY3JvcGhvbmVzIAoKIyBhcnJhbmdlbWVudCBvZiBtaWNyb3Bob25lcyAKCmdncGxvdChhcy5kYXRhLmZyYW1lKHRyYXBzKSxhZXMoeD14LHk9eSkpKwogIGdlb21fcG9pbnQoKSsKICB5bGltKC01LDEwKSsKICB4bGltKC01LDEwKSsKICBjb29yZF9maXhlZCgpKwogIHRoZW1lX2J3KCkKCiMgdGhpcmQgYXJndW1lbnQgTUFTSyAKIyB3ZSBjYW4gY3JlYXRlIG91ciBvd24gbWFzayB3aXRoIHRoZSBmdW5jdGlvbiBjcmVhdGUubWFzaygpIHdoaWNoIHRha2VzIHRoZSBzYW1lIHRyYXBzX0lECiMgZGF0YWZyYW1lIGFzIGZpcnN0IGFyZ3VtZW50IGFuZCB0aGVuIGJ1ZmZlciBkaXN0YW5jZSAKCm1hc2sgPC0gY3JlYXRlLm1hc2sodHJhcHMsIDE1KQoKIyBjcmVhdGUgY292YXJpYXRlIGRhdGEgZnJhbWUgdXNpbmcgbWFzayBjb29yZGluYXRlcyAKCmNvdl9kYXQgPC0gZGF0YS5mcmFtZSh4ID0gbWFza1ssMV0sIHkgPSBtYXNrWywyXSwgc3BhdF90cmVuZCA9ICJ5ZXMiKQoKIyBwbG90IG1hc2sgYW5kIGRldGVjdG9ycwoKZ2dwbG90KCkgKwogIGdlb21fcG9pbnQoZGF0YSA9IGFzLmRhdGEuZnJhbWUobWFza1ssMToyXSksIGFlcyh4ID0geCwgeSA9IHksIGNvbG9yID0gIk1hc2siKSwgYWxwaGEgPSAwLjIpICsKICBnZW9tX3BvaW50KGRhdGEgPSBhcy5kYXRhLmZyYW1lKHRyYXBzKSwgYWVzKHggPSB4LCB5ID0geSwgY29sb3IgPSAiRGV0ZWN0b3IiKSkgKwogIHNjYWxlX2NvbG9yX21hbnVhbCh2YWx1ZXMgPSBjKCJNYXNrIiA9ICJkYXJrZ3JleSIsICJEZXRlY3RvciIgPSAiYmx1ZSIpKSArCiAgbGFicyh0aXRsZSA9ICJIYWJpdGF0IG1hc2sgJiBtaWNyb3Bob25lcyIsIHggPSAiWCIsIHkgPSAiWSIpICsKICB0aGVtZV9taW5pbWFsKCkKCiMgT1IgCgojIGNhbiBwYXNzIGJ1ZmZlciBkaXN0YW5jZSB0byB0aGUgYXJndW1lbnQgY29udHJvbF9jcmVhdGVfbWFzayBpbiB0aGUgcmVhZC5hY3JlKCkgYW5kIGl0IHdpbGwKIyBjcmVhdGUgYSBtYXNrIGZvciB5b3UgCgojIGNyZWF0ZSBkYXRhIG9iamVjdCBmb3IgbW9kZWwgZml0dGluZyAKCmxpZ2h0Zm9vdGlfZGF0YSA8LSByZWFkLmFjcmUoCiAgY2FwdHVyZXMgPSBjYXB0dXJlcywKICB0cmFwcyA9IHRyYXBzLAogIG1hc2sgPSBtYXNrLCAKICBsb2NfY292ID0gY292X2RhdCwKICBjdWUucmF0ZXMgPSBjYWxsX3JhdGVzCikKCmNsYXNzKGxpZ2h0Zl9kYXRhKQoKIyMjIE1vZGVsIGZpdHRpbmcgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCgptb2RlbDEgPC0gZml0LmFjcmUoCiAgZGF0ID0gbGlnaHRmb290aV9kYXRhLAogIGRldGZuID0gImhuIiwKICBmaXggPSBsaXN0KGcwID0gMSkKKQoKIyMjIEluZmVyZW5jZSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KCiMgbW9kZWwgc3VtbWFyeSAKc3VtbWFyeShtb2RlbDEpCgojIHZhcmlhbmNlIAoKIyBtb2RlbDFfYm9vdCA8LSBib290LmFjcmUobW9kZWwxLCBOID0gMTApIAojIAojIG1vZGVsMV9ib290JGNvZWZmaWNpZW50cwojIAojIHN1bW1hcnkobW9kZWwxX2Jvb3QpCiMgCiMgYWNyZTo6c3RkRXIobW9kZWwxX2Jvb3QpICMgc3RhbmRhcmQgZXJyb3JzCiMgCiMgY29uZmludChtb2RlbDFfYm9vdCx0eXBlPSJmaXR0ZWQiKQoKIyBkZXRlY3Rpb24gZnVuY3Rpb24KCnNob3dfZGV0Zm4obW9kZWwxKQoKIyBkZW5zaXR5IAoKc2hvd19Ec3VyZihtb2RlbDEpICMgY29uc3RhbnQgbGlrZSB3ZSBzcGVjaWZpZWQgCgojIGFuaW1hbCBkZW5zaXR5IAoKIyBmaXJzdCBleHRyYWN0IGNhbGwgcmF0ZXMgY29udmVydGVkIHRvIG51bWJlciBvZiBjYWxscyBwZXIgc2Vjb25kIApjYWxsX3JhdGVzIDwtIGxpZ2h0Zm9vdGkkZnJlcXMvMTAwMAoKIyBTUEFUSUFMIFRSRU5EIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQoKIyMgQUNSRSBGb3JtYXR0aW5nIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQoKbGlnaHRmb290aV9kYXRhMiA8LSByZWFkLmFjcmUoCiAgY2FwdHVyZXMgPSBjYXB0dXJlcywKICB0cmFwcyA9IHRyYXBzLAogIG1hc2sgPSBtYXNrLAogIGxvY19jb3YgPSBjb3ZfZGF0LAogIGN1ZS5yYXRlcyA9IGNhbGxfcmF0ZXMKKQoKIyMgTW9kZWwgRml0dGluZyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KCm1vZGVsMiA8LSBmaXQuYWNyZSgKICBkYXQgPSBsaWdodGZvb3RpX2RhdGEyLAogIGRldGZuID0gImhuIiwgCiAgcGFyX2V4dGVuZF9tb2RlbCA9IGxpc3QoRD1+eCksCiAgZml4ID0gbGlzdChnMCA9IDEpCikKCgojIyBJbmZlcmVuY2UgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCgojIG1vZGVsIG91dHB1dCAKCnN1bW1hcnkobW9kZWwyKQoKIyAjIHZhcmlhbmNlIAojIAojIG1vZGVsMl9ib290IDwtIGJvb3QuYWNyZShtb2RlbDEsIE4gPSAxMCkgIyBib290c3RyYXBwaW5nCiMgCiMgYWNyZTo6c3RkRXIobW9kZWwyX2Jvb3QpICMgc3RhbmRhcmQgZXJyb3JzCiMgY29uZmludChtb2RlbDJfYm9vdCkgIyBjb25maWRlbmNlIGludGVydmFscyAKCiMgZGV0ZWN0aW9uIGZ1bmN0aW9uCgpzaG93X2RldGZuKG1vZGVsMikKCiMgZGVuc2l0eSAKCnNob3dfRHN1cmYobW9kZWwyKSAjIGNvbnN0YW50IGxpa2Ugd2Ugc3BlY2lmaWVkIAoKIyBCdWZmZXIgZGlzdGFuY2UgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQoKbGlicmFyeShzZWNyKQoKIyB0cmFwIGRhdGFmcmFtZSAKdHJhcHMkdHJhcCA8LSByb3duYW1lcyh0cmFwcykgIyBhZGQgdHJhcCBjb2x1bW4gd2l0aCB0cmFwIGlkcyAKCnNlY3JfdHJhcHMgPC0gcmVhZC50cmFwcyhkYXRhID0gdHJhcHMsICMgdHJhcCBsYXlvdXQgZGF0YQogICAgICAgICAgICAgICAgICAgICAgICAgdHJhcElEID0gInRyYXAiLCAjIG5hbWUgb2YgSUQgY29sdW1uCiAgICAgICAgICAgICAgICAgICAgICAgICBkZXRlY3RvciA9ICJwcm94aW1pdHkiKSAjIGRldGVjdG9yIHR5cGUKCnNlY3JfY2FwdGhpc3QgPC0gbWFrZS5jYXB0aGlzdChjYXB0dXJlcyA9IGNhcHR1cmVzLAogICAgICAgICAgICAgICAgICAgICAgdHJhcHMgPSBzZWNyX3RyYXBzLAogICAgICAgICAgICAgICAgICAgICAgZm10ID0gInRyYXBJRCIpCgojIHF1aWNrIGFuZCBiaWFzZWQgc2lnbWEKCmluaXRpYWxzaWdtYSA8LSBSUFNWKHNlY3JfY2FwdGhpc3QsIENDID0gVFJVRSkKCmJ1ZmZlcmRpc3QgPC0gNCAqIGluaXRpYWxzaWdtYQoKIyB1c2luZyBzdWdnZXN0LmJ1ZmZlcigpCgpzdWdnZXN0LmJ1ZmZlcihzZWNyX2NhcHRoaXN0LCBkZXRlY3RmbiA9ICJoYXphcmQgaGFsZm5vcm1hbCIpIAoKCiMgc2F2ZSBkYXRhIGFzIHNpbmdsZSBSRGF0YSBvYmplY3QgZm9yIHR1dG9yaWFsCnNhdmUoY2FwdHVyZXMsdHJhcHMsbWFzayxsaWdodGZfZGF0YSwKICAgICBjYWxsX3JhdGVzLG1vZGVsMSxtb2RlbDFfYm9vdCwKICAgICBtb2RlbDIsIG1vZGVsMl9ib290LCAKICAgICBmaWxlPSJkYXRhL2NoYXB0ZXI1X2RhdGEuUkRhdGEiKQoKCiMgTGlzdCBvZiBvYmplY3RzIGluIGxpZ2h0Zm9vdGlfZGF0YS5SZGF0YQojIGxpZ2h0Zm9vdGlfY2FwdHVyZXMKIyBsaWdodGZvb3RpX3RyYXBzCiMgbWFzawojIGxpZ2h0Zl9kYXRhIChyZWFkLmFjcmUgZGF0YSBvYmplY3QpCiMgbW9kZWwxIGZpdAoKCgo=" download="lightfooti_basic.R">Download lightfooti_basic.R</a>
</div>
</div>
<div id="section-definitions" class="section level2">
<h2>Definitions</h2>
<p><strong>Abundance</strong> is the number of individuals in a
population or community.</p>
<p><strong>Change in Ratio</strong> methods infer animal abundance from
observing changes in proportions of certain sub-classes of the wildlife
population like … . after removing a known amount of individuals from
the population.</p>
<p><strong>Density</strong> refers to the number of individuals within a
certain area or volume. In the context of wildlife populations, it is
typically used to describe the number of individuals per unit area.</p>
<p><strong>Distance sampling</strong> is a statistical method used in
ecology to estimate the abundance or density of a population by
collecting data on the distances between observers and the individuals
they detect.</p>
<p><strong>Capture-recapture</strong> is an analytic framework to
estimate abundance and density of wildlife population which relies on
captures (or detections) and recaptures (or redetections) of individuals
in a population. The analytic framework can be applied to many different
survey techniques.</p>
<p><strong>Passive acoustic surveying</strong> is when specialized
microphones are used to record animal vocalisations. Contrast this to
active acoustic surveying where sound sources ….</p>
<p><strong>Plot sampling</strong> entails dividing up a landscape into
sampling units such as plots (or quadrats) or strips and counting all
individuals of the target species within the sampling units.</p>
<p><strong>Removal methods</strong> rely on systematically removing
groups of individual (i.e. samples) from the population and deriving
abundance from the reduction in the amount of individuals removed over
time.</p>
<p><strong>Survey</strong> in the context of SCR refers to the
structured event of going out and placing detectors in a predefined
arrangement and for a certain amount of time in order to collect data on
a wildlife population.</p>
<p><strong>Survey (or sampling) technique(s)</strong> are methods used
to detect/capture/record animals in the field. This includes techniques
such as camera trapping, DNA sampling, visual observation and many more.
In the context of acoustic surveying, this involves placing microphones
in a habitat to record the vocalisations of a specific species.</p>
<p><strong>Self-contained recording unit</strong> is a type of sound
recording device used in passive acoustic surveying that is designed to
record animal vocalisations. It is typically designed to be left in the
field for extended periods of time and may be powered by batteries or
solar panels, are often equipped with weather-resistant and durable
housing to protect against the elements and wildlife.</p>
<p><strong>Closed population</strong> a group of individuals or entities
within a defined area or system that remains constant over a specific
period, meaning that no new members are added, and no existing members
leave or die.</p>
<p><strong>Probability of detection</strong> is probability of observing
a detection unit. For example, the probability of hearing a call if call
is the detection unit, or the probability of detecting and animal (or
group) if animal (or group) is the detection unit. There are various
kinds of detection probabilities in SCR surveys, even for a single kind
of detection unit. For example, there is the probability that a single
detector detects a detection unit, and the probability that any detector
in an array detects a detection unit, (a larger probability, obviously),
and the probability that a detector makes a detection GIVEN the location
of the animal, and the probability that certain detectors detect a
detection unit while others don’t (the probability of a particular
“detection history”).</p>
<p><strong>Imperfect detection</strong> is a widespread phenomenon in
ecological studies and refers to when the probability of detection is
less than one. In ecological surveys, it is almost always impossible to
observe or detect all individuals of the populations due to either the
specific sampling technique, human error or other factors. Imperfect
detection can lead to biased or incomplete results and requires
specialized statistical methods to account for the uncertainties
introduced by the incomplete observations.</p>
<p><strong>Detection histories</strong> contain the detections and
re-detections of calls across detector arrays. Usually contained in a
dataframe with rows equal to the number of calls detected and a column
for each detector.If a call was detected at a microphone, the
corresponding enrty contains a “1” and if not, a zero.</p>
<p><strong>Buffer distance</strong> is the minimum distance between
detectors and the edge of the habitat mask. The distance should be large
enough to plausibly include all detected animals.</p>
<p><strong>Constant (or homogenous) density</strong> refers to when
animal locations are evenly spread out throughout the survey region.</p>
<p><strong>Detection function</strong> refers to the mathematical model
used to describe the relationship between distance and detection
probability, where distance is the distance between detectors and
detected animal locations.</p>
<p><strong>Habitat mask</strong> is set of coordinates that form an area
covering the detectors in an SCR survey. The extent of the mask is
determined by the buffer distance.</p>
<p><strong>Non-constant (or inhomogenous) density</strong> refers to
when animal locations are NOT evenly spread out, but occur in regions of
varying density across the survey region.</p>
<p><strong>Spatial capture-recapture</strong> (SCR) is a statistical
model for estimating animal abundance and density from capture history
data. SCR models combines a model for the distribution of animals in
space with a model for detection probability. By jointly modelling these
aspects, SCR produce reliable density estimates.</p>
<p><strong>Detection unit</strong></p>
<p><strong>Animal density</strong></p>
<p><strong>Group density</strong></p>
<p><strong>Calling density</strong></p>
<p><strong>Signal strength</strong></p>
<p><strong>Time of arrival</strong></p>
<p>
<script type="application/shiny-prerendered" data-context="server-start">

source("RScripts/Chapter2_Setup.R")
source("RScripts/Chapter3_Setup.R")
source("RScripts/Chapter5_Setup.R")

</script>
 
<script type="application/shiny-prerendered" data-context="server">
learnr:::register_http_handlers(session, metadata = NULL)
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::prepare_tutorial_state(session)
</script>
 
<script type="application/shiny-prerendered" data-context="server">
learnr:::i18n_observe_tutorial_language(input, session)
</script>


<script type="application/shiny-prerendered" data-context="server">
session$onSessionEnded(function() {
        learnr:::event_trigger(session, "session_stop")
      })
</script>
 
<script type="application/shiny-prerendered" data-context="server">
# Initial plot and empty dataframe

output$frogPopPlot <- renderPlot({
  ggplot() +
    geom_image(data = trapdf, aes(x = x, y = y, image = micro_image), size = 0.3) +
    xlim(-50, 150) +
    ylim(-50, 150) +
    theme_minimal() +
    theme(
      legend.position = "top",
      legend.title = element_blank(),
      panel.background = element_rect(fill = "#c1e0cb"),
      axis.title = element_blank(),
      axis.text = element_blank(),
      axis.ticks = element_blank(),
      panel.grid.minor = element_blank(),
      panel.grid.major = element_blank()
    )
})

output$captHistData <- DT::renderDT({
  empty_dat <- matrix(nrow = 10, ncol = 9)
  colnames(empty_dat) <- paste0("M", 1:9)

  datatable(empty_dat,
    rownames = TRUE,
    class = "cell-border",
    escape = FALSE,
    extensions = "Buttons",
    selection = "single",
    options = list(dom = "t", ordering = F)
  )
})

# metrics

output$trueN <- shinydashboard::renderValueBox({
  N <- 0
  shinydashboard::valueBox(N, "True number of calls")
})

output$estN <- shinydashboard::renderValueBox({
  shinydashboard::valueBox(0, "Estimated number of calls")
})

output$probD <- shinydashboard::renderValueBox({
  shinydashboard::valueBox(0, "Overall probability of detection")
})


# Create a reactive dataframe to store locations of frogs
points <- reactiveVal(data.frame(x = numeric(0), y = numeric(0)))
cpt_rv <- reactiveVal(NULL)

# Add frogs when the addBtn is clicked
observeEvent(input$addBtn, {
  temppop <- sim.popn(D = 5, expand.grid(x = c(0, 100), y = c(0, 100)), buffer = 50)
  popdf <- data.frame(temppop)

  points(temppop)

  # Render new plot with frogs
  output$frogPopPlot <- renderPlot({
    ggplot(points(), aes(x = x, y = y)) +
      geom_image(image = frog_image, colour = "#8A3A0D", size = 0.09) +
      geom_image(data = trapdf, aes(x = x, y = y, image = micro_image), size = 0.25) +
      xlim(-50, 150) +
      ylim(-50, 150) +
      geom_text(aes(label = rownames(points())), vjust = 0.5, hjust = 0.5, colour = "white", size = 4, fontface = "bold") +
      theme(
        legend.position = "top",
        legend.title = element_blank(),
        panel.background = element_rect(fill = "#c1e0cb"),
        axis.title = element_blank(),
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        panel.grid.minor = element_blank(),
        panel.grid.major = element_blank()
      )
  })

  output$trueN <- shinydashboard::renderValueBox({
    N <- nrow(points())
    shinydashboard::valueBox(N, "Number of calls")
  })
})


# Add points when the button is clicked
observeEvent(input$detBtn, {
  if (is.null(points()) || nrow(points()) == 0) {
    # Display an error if points are empty
    showModal(modalDialog(
      title = "Oops!",
      "Please add frogs before surveying!",
      easyClose = TRUE
    ))
  } else {
    cpt <- sim.capthist(det_array,
      detectpar = list(g0 = 1, sigma = 20),
      noccasions = 1,
      popn = points(), renumber = FALSE
    )

    cpt_rv(cpt) # add to reactive dataframe for use outside observe

    prob_hist <- matrix(NA, nrow = dim(cpt)[1], ncol = dim(cpt)[3])
    rownames(prob_hist) <- names(cpt[, , 1])

    for (i in 1:9) {
      prob_hist[, i] <- cpt[, , i]
    }

    # # Calculate probabilities
    # prob_hist <- matrix(NA, nrow = nrow(points()), ncol = nrow(trapdf))
    # for (i in 1:nrow(trapdf)) {
    #   prob_hist[, i] <- calculate_prob_succ(points(), trapdf[i, ])
    # }

    det_ind <- as.data.frame(prob_hist)
    rownames(det_ind) <- paste("Frog", rownames(det_ind))
    colnames(det_ind) <- paste("M", 1:9)
    # det_ind <- det_ind[rowSums(det_ind[, 1:8]) > 0, ]

    output$captHistData <- DT::renderDT({
      det_ind %>%
        DT::datatable(
          rownames = TRUE,
          class = "cell-border",
          escape = FALSE,
          extensions = "Buttons",
          selection = "single",
          options = list(dom = "t", ordering = F)
        ) %>%
        formatStyle(0, target = "row", color = "black", lineHeight = "50%") %>%
        formatStyle(0, width = "20%")
    })


    # Render the plot
    output$frogPopPlot <- renderPlot({
      det_dat <- points() %>%
        mutate(
          det = ifelse(row_number() %in% rownames(cpt_rv()), "Detected", "Not Detected"),
          num = row_number()
        )

      ggplot(det_dat) +
        geom_image(aes(x = x, y = y, colour = det, image = frog_image), size = 0.09) +
        geom_image(data = trapdf, aes(x = x, y = y, image = micro_image), size = 0.25) +
        geom_text(aes(x = x, y = y, label = num), vjust = 0.5, hjust = 0.5, colour = "white", size = 4, fontface = "bold") +
        scale_color_manual(values = c(
          "Detected" = "darkgreen",
          "Not Detected" = "darkred"
        )) +
        xlim(-50, 150) +
        ylim(-50, 150) +
        theme(
          legend.position = "bottom",
          legend.title = element_blank(),
          panel.background = element_rect(fill = "#c1e0cb"),
          axis.title = element_blank(),
          axis.text = element_blank(),
          axis.ticks = element_blank(),
          panel.grid.minor = element_blank(),
          panel.grid.major = element_blank(),
          legend.text = element_text(size = 12)
        )
    })

    output$trueN <- shinydashboard::renderValueBox({
      N <- nrow(points())
      shinydashboard::valueBox(N, "True number of calls")
    })

    output$estN <- shinydashboard::renderValueBox({
      p_star <- 1 - (1 - mean(prob_hist))^nrow(det_array)
      Nhat <- nrow(det_ind) / p_star
      shinydashboard::valueBox(round(Nhat), "Estimated number of calls")
    })

    output$probD <- shinydashboard::renderValueBox({
      p_star <- 1 - (1 - mean(prob_hist))^nrow(det_array)
      shinydashboard::valueBox(round(p_star, 2), "Overall probability of detection")
    })
  }
})

# Reset to initial state when "Start Over" button is clicked
observeEvent(input$startOverBtn, {
  points(data.frame(x = numeric(0), y = numeric(0)))

  output$frogPopPlot <- renderPlot({
    ggplot() +
      geom_image(data = trapdf, aes(x = x, y = y, image = micro_image), size = 0.25) +
      xlim(-50, 150) +
      ylim(-50, 150) +
      theme(
        legend.position = "top",
        legend.title = element_blank(),
        panel.background = element_rect(fill = "#c1e0cb"),
        axis.title = element_blank(),
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        panel.grid.minor = element_blank(),
        panel.grid.major = element_blank()
      )
  })

  output$simPlot <- renderPlot({
    NULL
  })

  output$captHistData <- DT::renderDT({
    empty_dat <- matrix(nrow = 10, ncol = 9)
    colnames(empty_dat) <- paste0("M", 1:9)

    datatable(empty_dat,
      rownames = TRUE,
      class = "cell-border",
      escape = FALSE,
      extensions = "Buttons",
      selection = "single",
      options = list(dom = "t", ordering = F)
    )
  })

  output$trueN <- shinydashboard::renderValueBox({
    N <- 0
    shinydashboard::valueBox(N, "True number of calls")
  })

  output$estN <- shinydashboard::renderValueBox({
    shinydashboard::valueBox(0, "Estimated number of calls")
  })

  output$probD <- shinydashboard::renderValueBox({
    shinydashboard::valueBox(0, "Overall probability of detection")
  })
})

# Simualtion

observeEvent(input$repeatBtn, {
  if (is.null(points()) || nrow(points()) == 0) {
    # Display an error if points are empty
    showModal(modalDialog(
      title = "Oops!",
      "Please add frogs before surveying!",
      easyClose = TRUE
    ))
  } else {
    showModal(modalDialog("Surveying!", footer = NULL))
    simulate_surveys <- function(points, micro, nsims = 1000) {
      nhats <- rep(0, nsims)
      for (i in 1:nsims) {
        # capture histories
        CH <- sim.capthist(micro,
          detectpar = list(g0 = 1, sigma = 20),
          noccasions = 1,
          popn = points, renumber = FALSE
        )

        CH_combined <- matrix(NA, nrow = dim(CH)[1], ncol = dim(CH)[3])
        rownames(CH_combined) <- names(CH[, , 1])

        for (j in 1:9) {
          CH_combined[, j] <- CH[, , j]
        }

        ave <- 1 - (1 - mean(CH_combined))^nrow(micro)
        Nhat <- nrow(CH_combined) / ave

        nhats[i] <- Nhat
      }

      return(list(nhats = nhats, true = nrow(points())))
    }

    data5000 <- suppressWarnings(simulate_surveys(points(), det_array))

    output$simPlot <- renderPlotly({
      ggplotly(
        ggplot(data.frame(nhats = data5000$nhats), aes(x = nhats)) +
          geom_histogram(bins = 10, fill = "#97cba9", colour = "#668ba4") +
          geom_vline(aes(colour = "True_Number", xintercept = data5000$true)) +
          scale_color_manual(name = "", values = c(True_Number= "#C86F35")) +
          theme_minimal() +
          labs(
            x = "\nAbundance estimates",
            y = "Count\n"
          ) +
          theme(
            axis.text = element_text(size = 10),
            axis.title = element_text(size = 10)
          ),
        tooltip = c("y"), showlegend = F
      ) %>%
        layout(legend = list(
          orientation = "h"
        ))
    })
    removeModal()
  }
})
</script>


<script type="application/shiny-prerendered" data-context="server">
output$histDistPlot <- renderPlotly({
  ggplotly(
    ggplot(distdf, aes(x = dist)) +
      geom_histogram(
        alpha = 0.5, binwidth = 10,
        center = 5, position = "identity",
        colour = "#5b7a65",
        fill = "#97CBA9"
      ) +
      labs(
        x = "\nDistance (m)",
        y = "Count\n"
      ) +
      scale_x_continuous(breaks=seq(0,200,10)) +
      theme_minimal() +
      theme(
        axis.text = element_text(size = 10),
        axis.title = element_text(size = 10),
      ),
    tooltip = c("y")
  )
})

observeEvent(input$allFrogs, {
  output$histDistPlot <- renderPlotly({
    ggplotly(
      ggplot(distdf, aes(x = dist)) +
        geom_histogram(
          alpha = 0.5, binwidth = 10,
          center = 5, position = "identity",
          colour = "#5b7a65",
          fill = "#97CBA9"
        ) +
        labs(
          x = "\nDistance (m)",
          y = "Count\n"
        ) +
        theme_minimal() +
      scale_x_continuous(breaks=seq(0,200,10)) +
        theme(
          axis.text = element_text(size = 10),
          axis.title = element_text(size = 10),
        ),
      tooltip = c("y")
    )
  })
})
# Add detections

observeEvent(input$addDet, {
  output$histDistPlot <- renderPlotly({
    ggplotly(
      ggplot(distdf, aes(x = dist, fill = group, colour = group)) +
        geom_histogram(
          alpha = 0.5, binwidth = 10,
          center = 5, position = "identity"
        ) +
        scale_fill_manual(
          values = c("#97CBA9", "#668BA4"),
          labels = c("All", "Detected"),
          guide = guide_legend(title = "", position = "top")
        ) +
        scale_color_manual(
          values = c("#5b7a65", "#142D4C"),
          labels = c("All", "Detected"),
          guide = guide_legend(title = "", position = "top")
        ) +
        labs(
          x = "\nDistance (m)",
          y = "Count\n"
        ) +
      scale_x_continuous(breaks=seq(0,200,10)) +
        theme_minimal() +
        theme(
          axis.text = element_text(size = 10),
          axis.title = element_text(size = 10),
        ),
      tooltip = c("y")
    ) %>%
        layout(legend = list(
          orientation = "h"
        ))
  })
})

observeEvent(input$propBtn, {
  output$histDistPlot <- renderPlotly({
    ggplotly(
      ggplot(distdf[distdf$dist <= 50, ], aes(x = dist, fill = group, colour = group)) +
        geom_histogram(
          alpha = 0.5, binwidth = 10,
          center = 5, position = "identity"
        ) +
        scale_fill_manual(
          values = c("#97CBA9", "#668BA4"),
          labels = c("All", "Detected"),
          guide = guide_legend(title = "")
        ) +
        scale_color_manual(
          values = c("#5b7a65", "#142D4C"),
          labels = c("All", "Detected"),
          guide = guide_legend(title = "")
        ) +
        labs(
          x = "\nDistance (m)",
          y = "Count\n"
        ) +
        theme_minimal() +
        theme(
          axis.text = element_text(size = 10),
          axis.title = element_text(size = 10),
          legend.position = "top"
        ),
      tooltip = c("y")
    ) %>%
        layout(legend = list(
          orientation = "h"
        ))
  })

  output$propPlot <- renderPlotly({
    ggplotly(
      # Plot the bar plot
      ggplot(prop, aes(x = Var1, y = Freq)) +
        geom_bar(stat = "identity", colour = "#5b7a65", fill = "#97CBA9") +
        labs(x = "\nDistance (m)",
             y = "Probability of detection\n") +
        theme_minimal() +
        theme(
          axis.text = element_text(size = 10),
          axis.title = element_text(size = 10)
        ),
      tooltip = c("y")
    )
    
  })
})
</script>
 
<script type="application/shiny-prerendered" data-context="server">
# Shiny Server

  observeEvent(input$detFunc == detfunctions[5], {
    updateSliderInput(
      session = session,
      inputId = "g0",
      label = "Set value for λ0",
      max = 5
    )
  }, ignoreInit = TRUE)

output$detFuncPlot <- renderPlot({
  if (input$detFunc == detfunctions[1]) {
    y <- halfnormal(dist_seq, input$g0, input$sigma)
  } else if (input$detFunc == detfunctions[2]) {
    y <- hazard_rate(dist_seq, input$g0, input$sigma, input$z)
  } else if (input$detFunc == detfunctions[3]) {
    y <- exponential(dist_seq, input$g0, input$sigma)
  } else if (input$detFunc == detfunctions[4]) {
    y <- uniform(dist_seq, input$g0, input$sigma)
  } else if (input$detFunc == detfunctions[5]) {
    y <- hazard_halfnormal(dist_seq, input$g0, input$sigma)
  }

  # Create data frame
  df <- data.frame(d = dist_seq, y = y)

  # Plot
  ggplot(df, aes(d, y)) +
    geom_line(linewidth = 1, colour = "#97CBA9") +
    labs(title = paste(input$detFunc, "Detection Function")) +
    xlab("\nDistance") +
    ylab("Detection probability\n") +
    ylim(0, 1) +
    theme_minimal() +
    theme(
      axis.title = element_text(size = 15),
      plot.title = element_text(size = 20)
    )
})
</script>


<script type="application/shiny-prerendered" data-context="server">
output$maskBufferPlot <- renderPlot({
  mask <- create.mask(traps = trapdf, buffer = input$buffer)

  masks_df <- rbind(mask[, 1:2], trapdf)
  masks_df$type <- rep(c("Mask Point", "Detector"), c(nrow(mask), nrow(trapdf)))


  ggplot() +
    geom_point(data = masks_df, aes(x = x, y = y), alpha = 0.75, colour = "#678BA4") +
    geom_image(data = trapdf, aes(x = x, y = y, image = micro_image), size = 0.2) +
    theme_minimal() +
    coord_fixed() +
    labs(
      x = "\nX",
      y = "Y"
    ) +
    theme(
      legend.position = "bottom",
      legend.title = element_blank(),
      panel.background = element_rect(fill = "#c1e0cb")
    )
})
</script>
 
<script type="application/shiny-prerendered" data-context="server">
output$constantDensityPlot <- renderPlot({
  set.seed(1908) # set seed
  temppop <- sim.popn(D = input$density, expand.grid(x = c(0, 100), y = c(0, 100)), buffer = 50)

  ggplot(temppop, aes(x = x, y = y)) +
    geom_point() +
    labs(
      x = "\nX",
      y = "Y\n"
    ) +
    coord_fixed() +
    theme(
      legend.position = "top",
      legend.title = element_blank(),
      panel.background = element_rect(fill = "#c1e0cb"),
      panel.grid.minor = element_blank(),
      panel.grid.major = element_blank()
    ) +
    scale_x_continuous(n.breaks = 15) +
    scale_y_continuous(n.breaks = 10)
})
</script>


<script type="application/shiny-prerendered" data-context="server">
output$linearPlot <- renderPlot({
  ggplot(linear_mod$pred_data) +
    aes(x = X, y = Y, z = Density, fill = Density) +
    geom_tile() +
    geom_contour(color = "grey", alpha = 0.5) +
    geom_text_contour(aes(z = Density), stroke = 0.1, colour = "grey") +
    coord_equal() +
    scale_fill_viridis() +
    theme_bw()
})

output$quadPlot <- renderPlot({
  ggplot(quad_mod$pred_data) +
    aes(x = X, y = Y, z = Density, fill = Density) +
    geom_tile() +
    geom_contour(color = "grey", alpha = 0.5) +
    geom_text_contour(aes(z = Density), stroke = 0.1, colour = "grey") +
    coord_equal() +
    scale_fill_viridis() +
    theme_bw()
})


output$noisePlot <- renderPlot({
  # noise covariate data
  noise_data <- noise_mod$model_fit$all.covariates
  colnames(noise_data)[3] <- "Noise"

  ggplot(noise_data) +
    aes(x = x, y = y, z = Noise, fill = Noise) +
    geom_tile() +
    geom_contour(color = "grey", alpha = 0.5) +
    geom_text_contour(aes(z = Noise), stroke = 0.1, colour = "grey") +
    coord_equal() +
    scale_fill_distiller(palette = "Spectral") +
    theme_bw()
})

output$noiseDensityPlot <- renderPlot({
  ggplot(noise_mod$pred_data) +
    aes(x = X, y = Y, z = Density, fill = Density) +
    geom_tile() +
    geom_contour(color = "grey", alpha = 0.5) +
    geom_text_contour(aes(z = Density), stroke = 0.1, colour = "grey") +
    coord_equal() +
    scale_fill_viridis() +
    theme_bw()
})

output$forestPlot <- renderPlot({
  ggplot(forest_mod$pred_data) +
    aes(x = X, y = Y, z = Density, fill = Density) +
    geom_tile() +
    geom_contour(color = "grey", alpha = 0.5) +
    geom_text_contour(aes(z = Density), stroke = 0.1, colour = "grey") +
    coord_equal() +
    scale_fill_viridis() +
    theme_bw()
})
</script>
 
<script type="application/shiny-prerendered" data-context="server">
learnr:::question_prerendered_chunk(structure(list(type = "learnr_radio", label = "quiz1-1", question = structure("How many parameters does a SCR model with constant density and a halfnormal detection function have?", html = TRUE, class = c("html", 
"character")), answers = list(structure(list(id = "lnr_ans_b186a7c", 
    option = "1 (Density)", value = "1 (Density)", label = structure("1 (Density)", html = TRUE, class = c("html", 
    "character")), correct = FALSE, message = structure("Almost, but what about the detection function?", html = TRUE, class = c("html", 
    "character")), type = "literal"), class = c("tutorial_question_answer", 
"tutorial_quiz_answer")), structure(list(id = "lnr_ans_2788a4f", 
    option = "3 (g0,σ and density)", value = "3 (g0,σ and density)", 
    label = structure("3 (g0,σ and density)", html = TRUE, class = c("html", 
    "character")), correct = TRUE, message = structure("Woohoo! That’s correct :)", html = TRUE, class = c("html", 
    "character")), type = "literal"), class = c("tutorial_question_answer", 
"tutorial_quiz_answer")), structure(list(id = "lnr_ans_c4d57eb", 
    option = "2 (probability of detection and density)", value = "2 (probability of detection and density)", 
    label = structure("2 (probability of detection and density)", html = TRUE, class = c("html", 
    "character")), correct = FALSE, message = structure("Not quite, remember probability of detection is now a function of distance.", html = TRUE, class = c("html", 
    "character")), type = "literal"), class = c("tutorial_question_answer", 
"tutorial_quiz_answer")), structure(list(id = "lnr_ans_51f3f29", 
    option = "4 (g0, σ, habitat mask and density)", value = "4 (g0, σ, habitat mask and density)", 
    label = structure("4 (g0, σ, habitat mask and density)", html = TRUE, class = c("html", 
    "character")), correct = FALSE, message = structure("Close, but remember we have to specify the habitat mask so that our model can estimate density.", html = TRUE, class = c("html", 
    "character")), type = "literal"), class = c("tutorial_question_answer", 
"tutorial_quiz_answer"))), button_labels = list(submit = structure("<span data-i18n=\"button.questionsubmit\">Submit Answer<\u002fspan>", html = TRUE, class = c("html", 
"character")), try_again = structure("<span data-i18n=\"button.questiontryagain\">Try Again<\u002fspan>", html = TRUE, class = c("html", 
"character"))), messages = list(correct = structure("Correct!", html = TRUE, class = c("html", 
"character")), try_again = structure("Incorrect", html = TRUE, class = c("html", 
"character")), incorrect = structure("Incorrect", html = TRUE, class = c("html", 
"character")), message = NULL, post_message = NULL), ids = list(
    answer = "quiz1-1-answer", question = "quiz1-1"), loading = NULL, 
    random_answer_order = TRUE, allow_retry = TRUE, seed = 480199501.77639, 
    options = list()), class = c("learnr_radio", "tutorial_question"
)), session = session)
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::question_prerendered_chunk(structure(list(type = "learnr_radio", label = "quiz1-2", question = structure("What is the primary purpose of SCR models?", html = TRUE, class = c("html", 
"character")), answers = list(structure(list(id = "lnr_ans_8164d09", 
    option = "To estimate animal density", value = "To estimate animal density", 
    label = structure("To estimate animal density", html = TRUE, class = c("html", 
    "character")), correct = TRUE, message = NULL, type = "literal"), class = c("tutorial_question_answer", 
"tutorial_quiz_answer")), structure(list(id = "lnr_ans_43e4173", 
    option = "To estimate the probability of detection", value = "To estimate the probability of detection", 
    label = structure("To estimate the probability of detection", html = TRUE, class = c("html", 
    "character")), correct = FALSE, message = NULL, type = "literal"), class = c("tutorial_question_answer", 
"tutorial_quiz_answer")), structure(list(id = "lnr_ans_929c491", 
    option = "To identify individual animals from CR data", value = "To identify individual animals from CR data", 
    label = structure("To identify individual animals from CR data", html = TRUE, class = c("html", 
    "character")), correct = FALSE, message = NULL, type = "literal"), class = c("tutorial_question_answer", 
"tutorial_quiz_answer")), structure(list(id = "lnr_ans_5f9b0c9", 
    option = "To study animal movement and behaviour", value = "To study animal movement and behaviour", 
    label = structure("To study animal movement and behaviour", html = TRUE, class = c("html", 
    "character")), correct = FALSE, message = NULL, type = "literal"), class = c("tutorial_question_answer", 
"tutorial_quiz_answer"))), button_labels = list(submit = structure("<span data-i18n=\"button.questionsubmit\">Submit Answer<\u002fspan>", html = TRUE, class = c("html", 
"character")), try_again = structure("<span data-i18n=\"button.questiontryagain\">Try Again<\u002fspan>", html = TRUE, class = c("html", 
"character"))), messages = list(correct = structure("Correct!", html = TRUE, class = c("html", 
"character")), try_again = structure("Try again!", html = TRUE, class = c("html", 
"character")), incorrect = structure("Try again!", html = TRUE, class = c("html", 
"character")), message = NULL, post_message = NULL), ids = list(
    answer = "quiz1-2-answer", question = "quiz1-2"), loading = NULL, 
    random_answer_order = TRUE, allow_retry = TRUE, seed = 1185246269.44808, 
    options = list()), class = c("learnr_radio", "tutorial_question"
)), session = session)
</script>
 
<script type="application/shiny-prerendered" data-context="server">
learnr:::question_prerendered_chunk(structure(list(type = "learnr_radio", label = "quiz1-3", question = structure("What is the relationship between the buffer distance and the habitat mask?", html = TRUE, class = c("html", 
"character")), answers = list(structure(list(id = "lnr_ans_4eca9e4", 
    option = "The mask includes regions beyond the buffer distance.", 
    value = "The mask includes regions beyond the buffer distance.", 
    label = structure("The mask includes regions beyond the buffer distance.", html = TRUE, class = c("html", 
    "character")), correct = FALSE, message = NULL, type = "literal"), class = c("tutorial_question_answer", 
"tutorial_quiz_answer")), structure(list(id = "lnr_ans_a9e831e", 
    option = "The buffer distance is a parameter within the mask.", 
    value = "The buffer distance is a parameter within the mask.", 
    label = structure("The buffer distance is a parameter within the mask.", html = TRUE, class = c("html", 
    "character")), correct = FALSE, message = NULL, type = "literal"), class = c("tutorial_question_answer", 
"tutorial_quiz_answer")), structure(list(id = "lnr_ans_5ac0241", 
    option = "The buffer distance defines the mask area, it is the minimum distance between a detector and the mask boundary.", 
    value = "The buffer distance defines the mask area, it is the minimum distance between a detector and the mask boundary.", 
    label = structure("The buffer distance defines the mask area, it is the minimum distance between a detector and the mask boundary.", html = TRUE, class = c("html", 
    "character")), correct = TRUE, message = NULL, type = "literal"), class = c("tutorial_question_answer", 
"tutorial_quiz_answer")), structure(list(id = "lnr_ans_2e7a312", 
    option = "The mask defines the length of the buffer distance specified.", 
    value = "The mask defines the length of the buffer distance specified.", 
    label = structure("The mask defines the length of the buffer distance specified.", html = TRUE, class = c("html", 
    "character")), correct = FALSE, message = NULL, type = "literal"), class = c("tutorial_question_answer", 
"tutorial_quiz_answer"))), button_labels = list(submit = structure("<span data-i18n=\"button.questionsubmit\">Submit Answer<\u002fspan>", html = TRUE, class = c("html", 
"character")), try_again = structure("<span data-i18n=\"button.questiontryagain\">Try Again<\u002fspan>", html = TRUE, class = c("html", 
"character"))), messages = list(correct = structure("Correct!", html = TRUE, class = c("html", 
"character")), try_again = structure("Incorrect, if you’re unsure why not play around with the buffer distance again.", html = TRUE, class = c("html", 
"character")), incorrect = structure("Incorrect, if you’re unsure why not play around with the buffer distance again.", html = TRUE, class = c("html", 
"character")), message = NULL, post_message = NULL), ids = list(
    answer = "quiz1-3-answer", question = "quiz1-3"), loading = NULL, 
    random_answer_order = TRUE, allow_retry = TRUE, seed = 1555885039.77548, 
    options = list()), class = c("learnr_radio", "tutorial_question"
)), session = session)
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::question_prerendered_chunk(structure(list(type = "learnr_radio", label = "quiz1-4", question = structure("Which term is used to describe the assumption of animals being evenly distributed across space?", html = TRUE, class = c("html", 
"character")), answers = list(structure(list(id = "lnr_ans_2f4deec", 
    option = "Spatial point pattern", value = "Spatial point pattern", 
    label = structure("Spatial point pattern", html = TRUE, class = c("html", 
    "character")), correct = FALSE, message = NULL, type = "literal"), class = c("tutorial_question_answer", 
"tutorial_quiz_answer")), structure(list(id = "lnr_ans_e6509f6", 
    option = "Variable intensity", value = "Variable intensity", 
    label = structure("Variable intensity", html = TRUE, class = c("html", 
    "character")), correct = FALSE, message = NULL, type = "literal"), class = c("tutorial_question_answer", 
"tutorial_quiz_answer")), structure(list(id = "lnr_ans_a9680ea", 
    option = "Constant density", value = "Constant density", 
    label = structure("Constant density", html = TRUE, class = c("html", 
    "character")), correct = TRUE, message = NULL, type = "literal"), class = c("tutorial_question_answer", 
"tutorial_quiz_answer")), structure(list(id = "lnr_ans_148565d", 
    option = "Inhomogenous density", value = "Inhomogenous density", 
    label = structure("Inhomogenous density", html = TRUE, class = c("html", 
    "character")), correct = FALSE, message = NULL, type = "literal"), class = c("tutorial_question_answer", 
"tutorial_quiz_answer"))), button_labels = list(submit = structure("<span data-i18n=\"button.questionsubmit\">Submit Answer<\u002fspan>", html = TRUE, class = c("html", 
"character")), try_again = structure("<span data-i18n=\"button.questiontryagain\">Try Again<\u002fspan>", html = TRUE, class = c("html", 
"character"))), messages = list(correct = structure("Correct!", html = TRUE, class = c("html", 
"character")), try_again = structure("Nope!", html = TRUE, class = c("html", 
"character")), incorrect = structure("Nope!", html = TRUE, class = c("html", 
"character")), message = NULL, post_message = NULL), ids = list(
    answer = "quiz1-4-answer", question = "quiz1-4"), loading = NULL, 
    random_answer_order = TRUE, allow_retry = TRUE, seed = 1116595601.48004, 
    options = list()), class = c("learnr_radio", "tutorial_question"
)), session = session)
</script>
 
<script type="application/shiny-prerendered" data-context="server">
learnr:::question_prerendered_chunk(structure(list(type = "learnr_radio", label = "quiz1-5", question = structure("What component of an SCR model describes how animals are distributed throughout space?", html = TRUE, class = c("html", 
"character")), answers = list(structure(list(id = "lnr_ans_6f9fd90", 
    option = "Habitat mask", value = "Habitat mask", label = structure("Habitat mask", html = TRUE, class = c("html", 
    "character")), correct = FALSE, message = NULL, type = "literal"), class = c("tutorial_question_answer", 
"tutorial_quiz_answer")), structure(list(id = "lnr_ans_13ff2ba", 
    option = "Detection function", value = "Detection function", 
    label = structure("Detection function", html = TRUE, class = c("html", 
    "character")), correct = FALSE, message = NULL, type = "literal"), class = c("tutorial_question_answer", 
"tutorial_quiz_answer")), structure(list(id = "lnr_ans_abec671", 
    option = "Density model", value = "Density model", label = structure("Density model", html = TRUE, class = c("html", 
    "character")), correct = TRUE, message = NULL, type = "literal"), class = c("tutorial_question_answer", 
"tutorial_quiz_answer")), structure(list(id = "lnr_ans_b5b6822", 
    option = "Buffer distance", value = "Buffer distance", label = structure("Buffer distance", html = TRUE, class = c("html", 
    "character")), correct = FALSE, message = NULL, type = "literal"), class = c("tutorial_question_answer", 
"tutorial_quiz_answer"))), button_labels = list(submit = structure("<span data-i18n=\"button.questionsubmit\">Submit Answer<\u002fspan>", html = TRUE, class = c("html", 
"character")), try_again = structure("<span data-i18n=\"button.questiontryagain\">Try Again<\u002fspan>", html = TRUE, class = c("html", 
"character"))), messages = list(correct = structure("Correct!", html = TRUE, class = c("html", 
"character")), try_again = structure("Think about the marble example!", html = TRUE, class = c("html", 
"character")), incorrect = structure("Think about the marble example!", html = TRUE, class = c("html", 
"character")), message = NULL, post_message = NULL), ids = list(
    answer = "quiz1-5-answer", question = "quiz1-5"), loading = NULL, 
    random_answer_order = TRUE, allow_retry = TRUE, seed = 817265795.619431, 
    options = list()), class = c("learnr_radio", "tutorial_question"
)), session = session)
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::question_prerendered_chunk(structure(list(type = "learnr_checkbox", label = "quiz1-6", question = structure("In the context of SCR modeling, what does the ‘mask’ refer to?", html = TRUE, class = c("html", 
"character")), answers = list(structure(list(id = "lnr_ans_ab2c45a", 
    option = "A tool for capturing animals using detectors.", 
    value = "A tool for capturing animals using detectors.", 
    label = structure("A tool for capturing animals using detectors.", html = TRUE, class = c("html", 
    "character")), correct = FALSE, message = NULL, type = "literal"), class = c("tutorial_question_answer", 
"tutorial_quiz_answer")), structure(list(id = "lnr_ans_8afb462", 
    option = "A set of coordinates defining a habitat where animals occur.", 
    value = "A set of coordinates defining a habitat where animals occur.", 
    label = structure("A set of coordinates defining a habitat where animals occur.", html = TRUE, class = c("html", 
    "character")), correct = FALSE, message = NULL, type = "literal"), class = c("tutorial_question_answer", 
"tutorial_quiz_answer")), structure(list(id = "lnr_ans_3b52b47", 
    option = "A set of points or coordinates that define the area within which we are detecting animals.", 
    value = "A set of points or coordinates that define the area within which we are detecting animals.", 
    label = structure("A set of points or coordinates that define the area within which we are detecting animals.", html = TRUE, class = c("html", 
    "character")), correct = TRUE, message = NULL, type = "literal"), class = c("tutorial_question_answer", 
"tutorial_quiz_answer")), structure(list(id = "lnr_ans_a8df79c", 
    option = "The mask is a set of coordinates which defines our survey region over which we estimate density. ", 
    value = "The mask is a set of coordinates which defines our survey region over which we estimate density. ", 
    label = structure("The mask is a set of coordinates which defines our survey region over which we estimate density.", html = TRUE, class = c("html", 
    "character")), correct = TRUE, message = NULL, type = "literal"), class = c("tutorial_question_answer", 
"tutorial_quiz_answer"))), button_labels = list(submit = structure("<span data-i18n=\"button.questionsubmit\">Submit Answer<\u002fspan>", html = TRUE, class = c("html", 
"character")), try_again = structure("<span data-i18n=\"button.questiontryagain\">Try Again<\u002fspan>", html = TRUE, class = c("html", 
"character"))), messages = list(correct = structure("Correct!", html = TRUE, class = c("html", 
"character")), try_again = structure("Incorrect. Be sure to select every correct answer.", html = TRUE, class = c("html", 
"character")), incorrect = structure("Not quite!", html = TRUE, class = c("html", 
"character")), message = NULL, post_message = NULL), ids = list(
    answer = "quiz1-6-answer", question = "quiz1-6"), loading = NULL, 
    random_answer_order = TRUE, allow_retry = TRUE, seed = 1705770634.20569, 
    options = list()), class = c("learnr_checkbox", "tutorial_question"
)), session = session)
</script>
 
<script type="application/shiny-prerendered" data-context="server">
learnr:::question_prerendered_chunk(structure(list(type = "learnr_radio", label = "quiz1-7", question = structure("What is the main advantage of using a spatially explicit capture-recapture model?", html = TRUE, class = c("html", 
"character")), answers = list(structure(list(id = "lnr_ans_f8c9de6", 
    option = "It simplifies the analysis process.", value = "It simplifies the analysis process.", 
    label = structure("It simplifies the analysis process.", html = TRUE, class = c("html", 
    "character")), correct = FALSE, message = NULL, type = "literal"), class = c("tutorial_question_answer", 
"tutorial_quiz_answer")), structure(list(id = "lnr_ans_d767fb", 
    option = "It eliminates the need for habitat covariates.", 
    value = "It eliminates the need for habitat covariates.", 
    label = structure("It eliminates the need for habitat covariates.", html = TRUE, class = c("html", 
    "character")), correct = FALSE, message = NULL, type = "literal"), class = c("tutorial_question_answer", 
"tutorial_quiz_answer")), structure(list(id = "lnr_ans_a464137", 
    option = "It focuses only on animal density estimation.", 
    value = "It focuses only on animal density estimation.", 
    label = structure("It focuses only on animal density estimation.", html = TRUE, class = c("html", 
    "character")), correct = FALSE, message = NULL, type = "literal"), class = c("tutorial_question_answer", 
"tutorial_quiz_answer")), structure(list(id = "lnr_ans_89eca31", 
    option = "It accounts for spatial variation in detection probability.", 
    value = "It accounts for spatial variation in detection probability.", 
    label = structure("It accounts for spatial variation in detection probability.", html = TRUE, class = c("html", 
    "character")), correct = TRUE, message = NULL, type = "literal"), class = c("tutorial_question_answer", 
"tutorial_quiz_answer"))), button_labels = list(submit = structure("<span data-i18n=\"button.questionsubmit\">Submit Answer<\u002fspan>", html = TRUE, class = c("html", 
"character")), try_again = structure("<span data-i18n=\"button.questiontryagain\">Try Again<\u002fspan>", html = TRUE, class = c("html", 
"character"))), messages = list(correct = structure("Correct!", html = TRUE, class = c("html", 
"character")), try_again = structure("Not quite!", html = TRUE, class = c("html", 
"character")), incorrect = structure("Not quite!", html = TRUE, class = c("html", 
"character")), message = NULL, post_message = NULL), ids = list(
    answer = "quiz1-7-answer", question = "quiz1-7"), loading = NULL, 
    random_answer_order = TRUE, allow_retry = TRUE, seed = 692555739.177504, 
    options = list()), class = c("learnr_radio", "tutorial_question"
)), session = session)
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::question_prerendered_chunk(structure(list(type = "learnr_radio", label = "quiz1-8", question = structure("Which parameter of the detection function specifies the probability of detection when distance is zero?", html = TRUE, class = c("html", 
"character")), answers = list(structure(list(id = "lnr_ans_6260066", 
    option = "$g0$", value = "$g0$", label = structure("\\(g0\\)", html = TRUE, class = c("html", 
    "character")), correct = TRUE, message = NULL, type = "literal"), class = c("tutorial_question_answer", 
"tutorial_quiz_answer")), structure(list(id = "lnr_ans_8986e6e", 
    option = "$z0$", value = "$z0$", label = structure("\\(z0\\)", html = TRUE, class = c("html", 
    "character")), correct = FALSE, message = NULL, type = "literal"), class = c("tutorial_question_answer", 
"tutorial_quiz_answer")), structure(list(id = "lnr_ans_2326510", 
    option = "$\\sigma$", value = "$\\sigma$", label = structure("\\(\\sigma\\)", html = TRUE, class = c("html", 
    "character")), correct = FALSE, message = NULL, type = "literal"), class = c("tutorial_question_answer", 
"tutorial_quiz_answer")), structure(list(id = "lnr_ans_fba8b9a", 
    option = "$z$", value = "$z$", label = structure("\\(z\\)", html = TRUE, class = c("html", 
    "character")), correct = FALSE, message = NULL, type = "literal"), class = c("tutorial_question_answer", 
"tutorial_quiz_answer"))), button_labels = list(submit = structure("<span data-i18n=\"button.questionsubmit\">Submit Answer<\u002fspan>", html = TRUE, class = c("html", 
"character")), try_again = structure("<span data-i18n=\"button.questiontryagain\">Try Again<\u002fspan>", html = TRUE, class = c("html", 
"character"))), messages = list(correct = structure("Correct!", html = TRUE, class = c("html", 
"character")), try_again = structure("Not quite!", html = TRUE, class = c("html", 
"character")), incorrect = structure("Not quite!", html = TRUE, class = c("html", 
"character")), message = NULL, post_message = NULL), ids = list(
    answer = "quiz1-8-answer", question = "quiz1-8"), loading = NULL, 
    random_answer_order = TRUE, allow_retry = TRUE, seed = 729616679.160246, 
    options = list()), class = c("learnr_radio", "tutorial_question"
)), session = session)
</script>
 
<script type="application/shiny-prerendered" data-context="server">
learnr:::question_prerendered_chunk(structure(list(type = "learnr_checkbox", label = "quiz1-9", question = structure("Why can’t we assume constant probability of detection throughout the survey region?", html = TRUE, class = c("html", 
"character")), answers = list(structure(list(id = "lnr_ans_6ae3416", 
    option = "Animals closer to detectors are more likely to get detected than those further away.", 
    value = "Animals closer to detectors are more likely to get detected than those further away.", 
    label = structure("Animals closer to detectors are more likely to get detected than those further away.", html = TRUE, class = c("html", 
    "character")), correct = TRUE, message = NULL, type = "literal"), class = c("tutorial_question_answer", 
"tutorial_quiz_answer")), structure(list(id = "lnr_ans_60ac324", 
    option = "It is realistic, detectors can record animal calls equally regardless of where the animal are located.", 
    value = "It is realistic, detectors can record animal calls equally regardless of where the animal are located.", 
    label = structure("It is realistic, detectors can record animal calls equally regardless of where the animal are located.", html = TRUE, class = c("html", 
    "character")), correct = FALSE, message = NULL, type = "literal"), class = c("tutorial_question_answer", 
"tutorial_quiz_answer")), structure(list(id = "lnr_ans_70c3a92", 
    option = "Besides distance, other factors may also influence an animals' probability of detection such as the volume of it's call.", 
    value = "Besides distance, other factors may also influence an animals' probability of detection such as the volume of it's call.", 
    label = structure("Besides distance, other factors may also influence an animals’ probability of detection such as the volume of it’s call.", html = TRUE, class = c("html", 
    "character")), correct = TRUE, message = NULL, type = "literal"), class = c("tutorial_question_answer", 
"tutorial_quiz_answer")), structure(list(id = "lnr_ans_20b2830", 
    option = "Animals are evenly spread out, so distance doesn't matter. ", 
    value = "Animals are evenly spread out, so distance doesn't matter. ", 
    label = structure("Animals are evenly spread out, so distance doesn’t matter.", html = TRUE, class = c("html", 
    "character")), correct = FALSE, message = NULL, type = "literal"), class = c("tutorial_question_answer", 
"tutorial_quiz_answer"))), button_labels = list(submit = structure("<span data-i18n=\"button.questionsubmit\">Submit Answer<\u002fspan>", html = TRUE, class = c("html", 
"character")), try_again = structure("<span data-i18n=\"button.questiontryagain\">Try Again<\u002fspan>", html = TRUE, class = c("html", 
"character"))), messages = list(correct = structure("Correct!", html = TRUE, class = c("html", 
"character")), try_again = structure("Incorrect. Be sure to select every correct answer.", html = TRUE, class = c("html", 
"character")), incorrect = structure("Not quite!", html = TRUE, class = c("html", 
"character")), message = NULL, post_message = NULL), ids = list(
    answer = "quiz1-9-answer", question = "quiz1-9"), loading = NULL, 
    random_answer_order = TRUE, allow_retry = TRUE, seed = 1649562966.73186, 
    options = list()), class = c("learnr_checkbox", "tutorial_question"
)), session = session)
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::question_prerendered_chunk(structure(list(type = "learnr_radio", label = "quiz1-10", question = structure("What does the buffer distance ensure regarding detection probability?", html = TRUE, class = c("html", 
"character")), answers = list(structure(list(id = "lnr_ans_e1b0cbc", 
    option = "It ensures 100% detection within the buffer.", 
    value = "It ensures 100% detection within the buffer.", label = structure("It ensures 100% detection within the buffer.", html = TRUE, class = c("html", 
    "character")), correct = FALSE, message = NULL, type = "literal"), class = c("tutorial_question_answer", 
"tutorial_quiz_answer")), structure(list(id = "lnr_ans_efbfd9b", 
    option = "It prevents animals from being detected.", value = "It prevents animals from being detected.", 
    label = structure("It prevents animals from being detected.", html = TRUE, class = c("html", 
    "character")), correct = FALSE, message = NULL, type = "literal"), class = c("tutorial_question_answer", 
"tutorial_quiz_answer")), structure(list(id = "lnr_ans_d6cd9da", 
    option = "It provides a confidence interval for detection.", 
    value = "It provides a confidence interval for detection.", 
    label = structure("It provides a confidence interval for detection.", html = TRUE, class = c("html", 
    "character")), correct = FALSE, message = NULL, type = "literal"), class = c("tutorial_question_answer", 
"tutorial_quiz_answer")), structure(list(id = "lnr_ans_fdbec07", 
    option = " It ensures detection probability reaches zero within the sampled area.", 
    value = " It ensures detection probability reaches zero within the sampled area.", 
    label = structure("It ensures detection probability reaches zero within the sampled area.", html = TRUE, class = c("html", 
    "character")), correct = TRUE, message = NULL, type = "literal"), class = c("tutorial_question_answer", 
"tutorial_quiz_answer"))), button_labels = list(submit = structure("<span data-i18n=\"button.questionsubmit\">Submit Answer<\u002fspan>", html = TRUE, class = c("html", 
"character")), try_again = structure("<span data-i18n=\"button.questiontryagain\">Try Again<\u002fspan>", html = TRUE, class = c("html", 
"character"))), messages = list(correct = structure("Correct!", html = TRUE, class = c("html", 
"character")), try_again = structure("Not quite!", html = TRUE, class = c("html", 
"character")), incorrect = structure("Not quite!", html = TRUE, class = c("html", 
"character")), message = NULL, post_message = NULL), ids = list(
    answer = "quiz1-10-answer", question = "quiz1-10"), loading = NULL, 
    random_answer_order = TRUE, allow_retry = TRUE, seed = 1882508767.12339, 
    options = list()), class = c("learnr_radio", "tutorial_question"
)), session = session)
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-captures-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-captures-code-editor`)), session)
output$`tutorial-exercise-captures-output` <- renderUI({
  `tutorial-exercise-captures-result`()
})
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "captures", global_setup = structure(c("", 
"source(\"RScripts/Chapter2_Setup.R\")", "source(\"RScripts/Chapter3_Setup.R\")", 
"source(\"RScripts/Chapter5_Setup.R\")", ""), chunk_opts = list(
    label = "setup", include = FALSE)), setup = NULL, chunks = list(
    list(label = "captures", code = "head(captures) # shows first six detections", 
        opts = list(label = "\"captures\"", exercise = "TRUE", 
            exercise.eval = "FALSE"), engine = "r")), code_check = NULL, 
    error_check = NULL, check = NULL, solution = NULL, tests = NULL, 
    options = list(eval = FALSE, echo = TRUE, results = "markup", 
        tidy = FALSE, tidy.opts = NULL, collapse = FALSE, prompt = FALSE, 
        comment = NA, highlight = FALSE, size = "normalsize", 
        background = "#F7F7F7", strip.white = TRUE, cache = 0, 
        cache.path = "00_Welcome_cache/html/", cache.vars = NULL, 
        cache.lazy = TRUE, dependson = NULL, autodep = FALSE, 
        cache.rebuild = FALSE, fig.keep = "high", fig.show = "asis", 
        fig.align = "default", fig.path = "00_Welcome_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 6.5, fig.height = 4, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 624, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = FALSE, error = FALSE, 
        message = FALSE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        max.print = 1000, label = "captures", exercise = TRUE, 
        exercise.eval = FALSE, code = "head(captures) # shows first six detections", 
        out.width.px = 624, out.height.px = 384, params.src = "captures, exercise=TRUE,exercise.eval=FALSE", 
        fig.num = 0, exercise.df_print = "paged", exercise.checker = "NULL"), 
    engine = "r", version = "4"), class = c("r", "tutorial_exercise"
)))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-traps-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-traps-code-editor`)), session)
output$`tutorial-exercise-traps-output` <- renderUI({
  `tutorial-exercise-traps-result`()
})
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "traps", global_setup = structure(c("", 
"source(\"RScripts/Chapter2_Setup.R\")", "source(\"RScripts/Chapter3_Setup.R\")", 
"source(\"RScripts/Chapter5_Setup.R\")", ""), chunk_opts = list(
    label = "setup", include = FALSE)), setup = NULL, chunks = list(
    list(label = "traps", code = "head(traps)\n\n# plot trap locations\n\nggplot(traps, aes(x = x, y = y)) +\n  geom_point() +\n  coord_fixed() +\n  xlim(-5, 10) +\n  ylim(-5, 10) ", 
        opts = list(label = "\"traps\"", exercise = "TRUE", exercise.eval = "FALSE"), 
        engine = "r")), code_check = NULL, error_check = NULL, 
    check = NULL, solution = NULL, tests = NULL, options = list(
        eval = FALSE, echo = TRUE, results = "markup", tidy = FALSE, 
        tidy.opts = NULL, collapse = FALSE, prompt = FALSE, comment = NA, 
        highlight = FALSE, size = "normalsize", background = "#F7F7F7", 
        strip.white = TRUE, cache = 0, cache.path = "00_Welcome_cache/html/", 
        cache.vars = NULL, cache.lazy = TRUE, dependson = NULL, 
        autodep = FALSE, cache.rebuild = FALSE, fig.keep = "high", 
        fig.show = "asis", fig.align = "default", fig.path = "00_Welcome_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 6.5, fig.height = 4, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 624, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = FALSE, error = FALSE, 
        message = FALSE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        max.print = 1000, label = "traps", exercise = TRUE, exercise.eval = FALSE, 
        code = c("head(traps)", "", "# plot trap locations", 
        "", "ggplot(traps, aes(x = x, y = y)) +", "  geom_point() +", 
        "  coord_fixed() +", "  xlim(-5, 10) +", "  ylim(-5, 10) "
        ), out.width.px = 624, out.height.px = 384, params.src = "traps, exercise=TRUE,exercise.eval=FALSE", 
        fig.num = 0, exercise.df_print = "paged", exercise.checker = "NULL"), 
    engine = "r", version = "4"), class = c("r", "tutorial_exercise"
)))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-buffer-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-buffer-code-editor`)), session)
output$`tutorial-exercise-buffer-output` <- renderUI({
  `tutorial-exercise-buffer-result`()
})
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "buffer", global_setup = structure(c("", 
"source(\"RScripts/Chapter2_Setup.R\")", "source(\"RScripts/Chapter3_Setup.R\")", 
"source(\"RScripts/Chapter5_Setup.R\")", ""), chunk_opts = list(
    label = "setup", include = FALSE)), setup = NULL, chunks = list(
    list(label = "buffer", code = "# trap dataframe\ntraps$trap <- rownames(traps) # add trap column with trap ids\n\nsecr_traps <- read.traps(\n  data = traps, # trap layout data\n  trapID = \"trap\", # name of ID column\n  detector = \"proximity\"\n) # detector type\n\nsecr_capthist <- make.capthist(\n  captures = captures, # captures\n  traps = secr_traps, # traps\n  fmt = \"trapID\"\n) # format of captures\n\n# quick and biased sigma\ninitialsigma <- RPSV(\n  capthist = secr_capthist,\n  CC = TRUE\n)\n\nround(4 * initialsigma) # suggested buffer distance\n\n# using suggest.buffer()\n\nsuggest.buffer(object = secr_capthist, detectfn = \"HN\")", 
        opts = list(label = "\"buffer\"", exercise = "TRUE", 
            exercise.eval = "FALSE"), engine = "r")), code_check = NULL, 
    error_check = NULL, check = NULL, solution = NULL, tests = NULL, 
    options = list(eval = FALSE, echo = TRUE, results = "markup", 
        tidy = FALSE, tidy.opts = NULL, collapse = FALSE, prompt = FALSE, 
        comment = NA, highlight = FALSE, size = "normalsize", 
        background = "#F7F7F7", strip.white = TRUE, cache = 0, 
        cache.path = "00_Welcome_cache/html/", cache.vars = NULL, 
        cache.lazy = TRUE, dependson = NULL, autodep = FALSE, 
        cache.rebuild = FALSE, fig.keep = "high", fig.show = "asis", 
        fig.align = "default", fig.path = "00_Welcome_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 6.5, fig.height = 4, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 624, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = FALSE, error = FALSE, 
        message = FALSE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        max.print = 1000, label = "buffer", exercise = TRUE, 
        exercise.eval = FALSE, code = c("# trap dataframe", "traps$trap <- rownames(traps) # add trap column with trap ids", 
        "", "secr_traps <- read.traps(", "  data = traps, # trap layout data", 
        "  trapID = \"trap\", # name of ID column", "  detector = \"proximity\"", 
        ") # detector type", "", "secr_capthist <- make.capthist(", 
        "  captures = captures, # captures", "  traps = secr_traps, # traps", 
        "  fmt = \"trapID\"", ") # format of captures", "", "# quick and biased sigma", 
        "initialsigma <- RPSV(", "  capthist = secr_capthist,", 
        "  CC = TRUE", ")", "", "round(4 * initialsigma) # suggested buffer distance", 
        "", "# using suggest.buffer()", "", "suggest.buffer(object = secr_capthist, detectfn = \"HN\")"
        ), out.width.px = 624, out.height.px = 384, params.src = "buffer, exercise=TRUE,exercise.eval=FALSE", 
        fig.num = 0, exercise.df_print = "paged", exercise.checker = "NULL"), 
    engine = "r", version = "4"), class = c("r", "tutorial_exercise"
)))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-mask-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-mask-code-editor`)), session)
output$`tutorial-exercise-mask-output` <- renderUI({
  `tutorial-exercise-mask-result`()
})
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "mask", global_setup = structure(c("", 
"source(\"RScripts/Chapter2_Setup.R\")", "source(\"RScripts/Chapter3_Setup.R\")", 
"source(\"RScripts/Chapter5_Setup.R\")", ""), chunk_opts = list(
    label = "setup", include = FALSE)), setup = NULL, chunks = list(
    list(label = "mask", code = "# create mask\nmask <- create.mask(lightfooti_traps, buffer = 10)\n\n# inspect mask object\nhead(mask)\n\nggplot() +\n  geom_point(data = as.data.frame(mask), aes(x = x, y = y, color = \"Mask\"), alpha = 0.2) +\n  geom_point(data = traps, aes(x = x, y = y, color = \"Detector\")) +\n  scale_color_manual(values = c(\"Mask\" = \"darkgrey\", \"Detector\" = \"blue\")) +\n  labs(title = \"Habitat mask & microphones\", x = \"X\", y = \"Y\") +\n  theme(legend.title = element_blank())", 
        opts = list(label = "\"mask\"", exercise = "TRUE", exercise.eval = "FALSE"), 
        engine = "r")), code_check = NULL, error_check = NULL, 
    check = NULL, solution = NULL, tests = NULL, options = list(
        eval = FALSE, echo = TRUE, results = "markup", tidy = FALSE, 
        tidy.opts = NULL, collapse = FALSE, prompt = FALSE, comment = NA, 
        highlight = FALSE, size = "normalsize", background = "#F7F7F7", 
        strip.white = TRUE, cache = 0, cache.path = "00_Welcome_cache/html/", 
        cache.vars = NULL, cache.lazy = TRUE, dependson = NULL, 
        autodep = FALSE, cache.rebuild = FALSE, fig.keep = "high", 
        fig.show = "asis", fig.align = "default", fig.path = "00_Welcome_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 6.5, fig.height = 4, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 624, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = FALSE, error = FALSE, 
        message = FALSE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        max.print = 1000, label = "mask", exercise = TRUE, exercise.eval = FALSE, 
        code = c("# create mask", "mask <- create.mask(lightfooti_traps, buffer = 10)", 
        "", "# inspect mask object", "head(mask)", "", "ggplot() +", 
        "  geom_point(data = as.data.frame(mask), aes(x = x, y = y, color = \"Mask\"), alpha = 0.2) +", 
        "  geom_point(data = traps, aes(x = x, y = y, color = \"Detector\")) +", 
        "  scale_color_manual(values = c(\"Mask\" = \"darkgrey\", \"Detector\" = \"blue\")) +", 
        "  labs(title = \"Habitat mask & microphones\", x = \"X\", y = \"Y\") +", 
        "  theme(legend.title = element_blank())"), out.width.px = 624, 
        out.height.px = 384, params.src = "mask, exercise=TRUE,exercise.eval=FALSE", 
        fig.num = 0, exercise.df_print = "paged", exercise.checker = "NULL"), 
    engine = "r", version = "4"), class = c("r", "tutorial_exercise"
)))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-examp_loc-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-examp_loc-code-editor`)), session)
output$`tutorial-exercise-examp_loc-output` <- renderUI({
  `tutorial-exercise-examp_loc-result`()
})
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "examp_loc", global_setup = structure(c("", 
"source(\"RScripts/Chapter2_Setup.R\")", "source(\"RScripts/Chapter3_Setup.R\")", 
"source(\"RScripts/Chapter5_Setup.R\")", ""), chunk_opts = list(
    label = "setup", include = FALSE)), setup = NULL, chunks = list(
    list(label = "examp_loc", code = "example_loc_data <- data.frame(\n  x = c(-20, -20, -20, 2.5, 2.5, 2.5, 25, 25, 25),\n  y = c(-20, 5, 30, -20, 5, 30, -20, 5, 30),\n  noise = c(6, 10, 11, 7, 12, 10, 11, 9, 8),\n  forest_vol = c(\"high\", \"high\", \"median\", \"median\", \"median\", \"low\", \"low\", \"low\", \"low\")\n)\n\nhead(example_loc_data)", 
        opts = list(label = "\"examp_loc\"", exercise = "TRUE", 
            exercise.eval = "FALSE"), engine = "r")), code_check = NULL, 
    error_check = NULL, check = NULL, solution = NULL, tests = NULL, 
    options = list(eval = FALSE, echo = TRUE, results = "markup", 
        tidy = FALSE, tidy.opts = NULL, collapse = FALSE, prompt = FALSE, 
        comment = NA, highlight = FALSE, size = "normalsize", 
        background = "#F7F7F7", strip.white = TRUE, cache = 0, 
        cache.path = "00_Welcome_cache/html/", cache.vars = NULL, 
        cache.lazy = TRUE, dependson = NULL, autodep = FALSE, 
        cache.rebuild = FALSE, fig.keep = "high", fig.show = "asis", 
        fig.align = "default", fig.path = "00_Welcome_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 6.5, fig.height = 4, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 624, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = FALSE, error = FALSE, 
        message = FALSE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        max.print = 1000, label = "examp_loc", exercise = TRUE, 
        exercise.eval = FALSE, code = c("example_loc_data <- data.frame(", 
        "  x = c(-20, -20, -20, 2.5, 2.5, 2.5, 25, 25, 25),", 
        "  y = c(-20, 5, 30, -20, 5, 30, -20, 5, 30),", "  noise = c(6, 10, 11, 7, 12, 10, 11, 9, 8),", 
        "  forest_vol = c(\"high\", \"high\", \"median\", \"median\", \"median\", \"low\", \"low\", \"low\", \"low\")", 
        ")", "", "head(example_loc_data)"), out.width.px = 624, 
        out.height.px = 384, params.src = "examp_loc, exercise=TRUE,exercise.eval=FALSE", 
        fig.num = 0, exercise.df_print = "paged", exercise.checker = "NULL"), 
    engine = "r", version = "4"), class = c("r", "tutorial_exercise"
)))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-cov_dat-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-cov_dat-code-editor`)), session)
output$`tutorial-exercise-cov_dat-output` <- renderUI({
  `tutorial-exercise-cov_dat-result`()
})
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "cov_dat", global_setup = structure(c("", 
"source(\"RScripts/Chapter2_Setup.R\")", "source(\"RScripts/Chapter3_Setup.R\")", 
"source(\"RScripts/Chapter5_Setup.R\")", ""), chunk_opts = list(
    label = "setup", include = FALSE)), setup = NULL, chunks = list(
    list(label = "cov_dat", code = "cov_dat <- data.frame(x = mask[, 1], y = mask[, 2], spat_trend = \"yes\")\n\nlightfooti_data <- read.acre(\n  captures = captures,\n  traps = traps,\n  mask = mask,\n  loc_cov = cov_dat\n)\n\n# alternative mask creation\n\n# lightfooti_data <- read.acre(\n#   captures = captures,\n#   traps = traps,\n#   control_create_mask = list(buffer=10),\n#   loc_cov = cov_dat\n# )", 
        opts = list(label = "\"cov_dat\"", exercise = "TRUE", 
            exercise.eval = "FALSE"), engine = "r")), code_check = NULL, 
    error_check = NULL, check = NULL, solution = NULL, tests = NULL, 
    options = list(eval = FALSE, echo = TRUE, results = "markup", 
        tidy = FALSE, tidy.opts = NULL, collapse = FALSE, prompt = FALSE, 
        comment = NA, highlight = FALSE, size = "normalsize", 
        background = "#F7F7F7", strip.white = TRUE, cache = 0, 
        cache.path = "00_Welcome_cache/html/", cache.vars = NULL, 
        cache.lazy = TRUE, dependson = NULL, autodep = FALSE, 
        cache.rebuild = FALSE, fig.keep = "high", fig.show = "asis", 
        fig.align = "default", fig.path = "00_Welcome_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 6.5, fig.height = 4, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 624, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = FALSE, error = FALSE, 
        message = FALSE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        max.print = 1000, label = "cov_dat", exercise = TRUE, 
        exercise.eval = FALSE, code = c("cov_dat <- data.frame(x = mask[, 1], y = mask[, 2], spat_trend = \"yes\")", 
        "", "lightfooti_data <- read.acre(", "  captures = captures,", 
        "  traps = traps,", "  mask = mask,", "  loc_cov = cov_dat", 
        ")", "", "# alternative mask creation", "", "# lightfooti_data <- read.acre(", 
        "#   captures = captures,", "#   traps = traps,", "#   control_create_mask = list(buffer=10),", 
        "#   loc_cov = cov_dat", "# )"), out.width.px = 624, 
        out.height.px = 384, params.src = "cov_dat, exercise=TRUE,exercise.eval=FALSE", 
        fig.num = 0, exercise.df_print = "paged", exercise.checker = "NULL"), 
    engine = "r", version = "4"), class = c("r", "tutorial_exercise"
)))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-model1-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-model1-code-editor`)), session)
output$`tutorial-exercise-model1-output` <- renderUI({
  `tutorial-exercise-model1-result`()
})
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "model1", global_setup = structure(c("", 
"source(\"RScripts/Chapter2_Setup.R\")", "source(\"RScripts/Chapter3_Setup.R\")", 
"source(\"RScripts/Chapter5_Setup.R\")", ""), chunk_opts = list(
    label = "setup", include = FALSE)), setup = NULL, chunks = list(
    list(label = "model1", code = "model1 <- fit.acre(\n  dat = lightf_data,\n  detfn = \"hn\",\n  fix = list(g0=1)\n)", 
        opts = list(label = "\"model1\"", exercise = "TRUE", 
            exercise.eval = "FALSE"), engine = "r")), code_check = NULL, 
    error_check = NULL, check = NULL, solution = NULL, tests = NULL, 
    options = list(eval = FALSE, echo = TRUE, results = "markup", 
        tidy = FALSE, tidy.opts = NULL, collapse = FALSE, prompt = FALSE, 
        comment = NA, highlight = FALSE, size = "normalsize", 
        background = "#F7F7F7", strip.white = TRUE, cache = 0, 
        cache.path = "00_Welcome_cache/html/", cache.vars = NULL, 
        cache.lazy = TRUE, dependson = NULL, autodep = FALSE, 
        cache.rebuild = FALSE, fig.keep = "high", fig.show = "asis", 
        fig.align = "default", fig.path = "00_Welcome_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 6.5, fig.height = 4, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 624, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = FALSE, error = FALSE, 
        message = FALSE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        max.print = 1000, label = "model1", exercise = TRUE, 
        exercise.eval = FALSE, code = c("model1 <- fit.acre(", 
        "  dat = lightf_data,", "  detfn = \"hn\",", "  fix = list(g0=1)", 
        ")"), out.width.px = 624, out.height.px = 384, params.src = "model1, exercise=TRUE,exercise.eval=FALSE", 
        fig.num = 0, exercise.df_print = "paged", exercise.checker = "NULL"), 
    engine = "r", version = "4"), class = c("r", "tutorial_exercise"
)))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-inf1-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-inf1-code-editor`)), session)
output$`tutorial-exercise-inf1-output` <- renderUI({
  `tutorial-exercise-inf1-result`()
})
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "inf1", global_setup = structure(c("", 
"source(\"RScripts/Chapter2_Setup.R\")", "source(\"RScripts/Chapter3_Setup.R\")", 
"source(\"RScripts/Chapter5_Setup.R\")", ""), chunk_opts = list(
    label = "setup", include = FALSE)), setup = NULL, chunks = list(
    list(label = "inf1", code = "summary(model1)", opts = list(
        label = "\"inf1\"", exercise = "TRUE", exercise.eval = "FALSE"), 
        engine = "r")), code_check = NULL, error_check = NULL, 
    check = NULL, solution = NULL, tests = NULL, options = list(
        eval = FALSE, echo = TRUE, results = "markup", tidy = FALSE, 
        tidy.opts = NULL, collapse = FALSE, prompt = FALSE, comment = NA, 
        highlight = FALSE, size = "normalsize", background = "#F7F7F7", 
        strip.white = TRUE, cache = 0, cache.path = "00_Welcome_cache/html/", 
        cache.vars = NULL, cache.lazy = TRUE, dependson = NULL, 
        autodep = FALSE, cache.rebuild = FALSE, fig.keep = "high", 
        fig.show = "asis", fig.align = "default", fig.path = "00_Welcome_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 6.5, fig.height = 4, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 624, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = FALSE, error = FALSE, 
        message = FALSE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        max.print = 1000, label = "inf1", exercise = TRUE, exercise.eval = FALSE, 
        code = "summary(model1)", out.width.px = 624, out.height.px = 384, 
        params.src = "inf1, exercise=TRUE,exercise.eval=FALSE", 
        fig.num = 0, exercise.df_print = "paged", exercise.checker = "NULL"), 
    engine = "r", version = "4"), class = c("r", "tutorial_exercise"
)))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-boot-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-boot-code-editor`)), session)
output$`tutorial-exercise-boot-output` <- renderUI({
  `tutorial-exercise-boot-result`()
})
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "boot", global_setup = structure(c("", 
"source(\"RScripts/Chapter2_Setup.R\")", "source(\"RScripts/Chapter3_Setup.R\")", 
"source(\"RScripts/Chapter5_Setup.R\")", ""), chunk_opts = list(
    label = "setup", include = FALSE)), setup = NULL, chunks = list(
    list(label = "boot", code = "\n# boot_N10 <- boot.acre(model1, N = 10)\n\nstr(model1_boot)\n", 
        opts = list(label = "\"boot\"", exercise = "TRUE", exercise.eval = "FALSE"), 
        engine = "r")), code_check = NULL, error_check = NULL, 
    check = NULL, solution = NULL, tests = NULL, options = list(
        eval = FALSE, echo = TRUE, results = "markup", tidy = FALSE, 
        tidy.opts = NULL, collapse = FALSE, prompt = FALSE, comment = NA, 
        highlight = FALSE, size = "normalsize", background = "#F7F7F7", 
        strip.white = TRUE, cache = 0, cache.path = "00_Welcome_cache/html/", 
        cache.vars = NULL, cache.lazy = TRUE, dependson = NULL, 
        autodep = FALSE, cache.rebuild = FALSE, fig.keep = "high", 
        fig.show = "asis", fig.align = "default", fig.path = "00_Welcome_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 6.5, fig.height = 4, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 624, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = FALSE, error = FALSE, 
        message = FALSE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        max.print = 1000, label = "boot", exercise = TRUE, exercise.eval = FALSE, 
        code = c("", "# boot_N10 <- boot.acre(model1, N = 10)", 
        "", "str(model1_boot)", ""), out.width.px = 624, out.height.px = 384, 
        params.src = "boot, exercise=TRUE,exercise.eval=FALSE", 
        fig.num = 0, exercise.df_print = "paged", exercise.checker = "NULL"), 
    engine = "r", version = "4"), class = c("r", "tutorial_exercise"
)))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-stder-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-stder-code-editor`)), session)
output$`tutorial-exercise-stder-output` <- renderUI({
  `tutorial-exercise-stder-result`()
})
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "stder", global_setup = structure(c("", 
"source(\"RScripts/Chapter2_Setup.R\")", "source(\"RScripts/Chapter3_Setup.R\")", 
"source(\"RScripts/Chapter5_Setup.R\")", ""), chunk_opts = list(
    label = "setup", include = FALSE)), setup = NULL, chunks = list(
    list(label = "stder", code = "acre::stdEr(model1_boot)\n\nconfint(model1_boot, type=\"fitted\")", 
        opts = list(label = "\"stder\"", exercise = "TRUE", exercise.eval = "FALSE"), 
        engine = "r")), code_check = NULL, error_check = NULL, 
    check = NULL, solution = NULL, tests = NULL, options = list(
        eval = FALSE, echo = TRUE, results = "markup", tidy = FALSE, 
        tidy.opts = NULL, collapse = FALSE, prompt = FALSE, comment = NA, 
        highlight = FALSE, size = "normalsize", background = "#F7F7F7", 
        strip.white = TRUE, cache = 0, cache.path = "00_Welcome_cache/html/", 
        cache.vars = NULL, cache.lazy = TRUE, dependson = NULL, 
        autodep = FALSE, cache.rebuild = FALSE, fig.keep = "high", 
        fig.show = "asis", fig.align = "default", fig.path = "00_Welcome_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 6.5, fig.height = 4, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 624, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = FALSE, error = FALSE, 
        message = FALSE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        max.print = 1000, label = "stder", exercise = TRUE, exercise.eval = FALSE, 
        code = c("acre::stdEr(model1_boot)", "", "confint(model1_boot, type=\"fitted\")"
        ), out.width.px = 624, out.height.px = 384, params.src = "stder, exercise=TRUE,exercise.eval=FALSE", 
        fig.num = 0, exercise.df_print = "paged", exercise.checker = "NULL"), 
    engine = "r", version = "4"), class = c("r", "tutorial_exercise"
)))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-inf3-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-inf3-code-editor`)), session)
output$`tutorial-exercise-inf3-output` <- renderUI({
  `tutorial-exercise-inf3-result`()
})
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "inf3", global_setup = structure(c("", 
"source(\"RScripts/Chapter2_Setup.R\")", "source(\"RScripts/Chapter3_Setup.R\")", 
"source(\"RScripts/Chapter5_Setup.R\")", ""), chunk_opts = list(
    label = "setup", include = FALSE)), setup = NULL, chunks = list(
    list(label = "inf3", code = "summary(model1)\n\nshow_detfn(model1)", 
        opts = list(label = "\"inf3\"", exercise = "TRUE", exercise.eval = "FALSE"), 
        engine = "r")), code_check = NULL, error_check = NULL, 
    check = NULL, solution = NULL, tests = NULL, options = list(
        eval = FALSE, echo = TRUE, results = "markup", tidy = FALSE, 
        tidy.opts = NULL, collapse = FALSE, prompt = FALSE, comment = NA, 
        highlight = FALSE, size = "normalsize", background = "#F7F7F7", 
        strip.white = TRUE, cache = 0, cache.path = "00_Welcome_cache/html/", 
        cache.vars = NULL, cache.lazy = TRUE, dependson = NULL, 
        autodep = FALSE, cache.rebuild = FALSE, fig.keep = "high", 
        fig.show = "asis", fig.align = "default", fig.path = "00_Welcome_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 6.5, fig.height = 4, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 624, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = FALSE, error = FALSE, 
        message = FALSE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        max.print = 1000, label = "inf3", exercise = TRUE, exercise.eval = FALSE, 
        code = c("summary(model1)", "", "show_detfn(model1)"), 
        out.width.px = 624, out.height.px = 384, params.src = "inf3, exercise=TRUE,exercise.eval=FALSE", 
        fig.num = 0, exercise.df_print = "paged", exercise.checker = "NULL"), 
    engine = "r", version = "4"), class = c("r", "tutorial_exercise"
)))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-inf4-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-inf4-code-editor`)), session)
output$`tutorial-exercise-inf4-output` <- renderUI({
  `tutorial-exercise-inf4-result`()
})
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "inf4", global_setup = structure(c("", 
"source(\"RScripts/Chapter2_Setup.R\")", "source(\"RScripts/Chapter3_Setup.R\")", 
"source(\"RScripts/Chapter5_Setup.R\")", ""), chunk_opts = list(
    label = "setup", include = FALSE)), setup = NULL, chunks = list(
    list(label = "inf4", code = "\n# call rates\ncall_rates \n\n# model contents \nmodel1$coefficients\n\n# animal density\n(D_animal <- model1$coefficients[5] / mean(call_rates))  \n\n# convert to per hectare \nD_animal/10000 \n", 
        opts = list(label = "\"inf4\"", exercise = "TRUE", exercise.eval = "FALSE"), 
        engine = "r")), code_check = NULL, error_check = NULL, 
    check = NULL, solution = NULL, tests = NULL, options = list(
        eval = FALSE, echo = TRUE, results = "markup", tidy = FALSE, 
        tidy.opts = NULL, collapse = FALSE, prompt = FALSE, comment = NA, 
        highlight = FALSE, size = "normalsize", background = "#F7F7F7", 
        strip.white = TRUE, cache = 0, cache.path = "00_Welcome_cache/html/", 
        cache.vars = NULL, cache.lazy = TRUE, dependson = NULL, 
        autodep = FALSE, cache.rebuild = FALSE, fig.keep = "high", 
        fig.show = "asis", fig.align = "default", fig.path = "00_Welcome_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 6.5, fig.height = 4, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 624, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = FALSE, error = FALSE, 
        message = FALSE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        max.print = 1000, label = "inf4", exercise = TRUE, exercise.eval = FALSE, 
        code = c("", "# call rates", "call_rates ", "", "# model contents ", 
        "model1$coefficients", "", "# animal density", "(D_animal <- model1$coefficients[5] / mean(call_rates))  ", 
        "", "# convert to per hectare ", "D_animal/10000 ", ""
        ), out.width.px = 624, out.height.px = 384, params.src = "inf4, exercise=TRUE,exercise.eval=FALSE", 
        fig.num = 0, exercise.df_print = "paged", exercise.checker = "NULL"), 
    engine = "r", version = "4"), class = c("r", "tutorial_exercise"
)))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-acre_data2-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-acre_data2-code-editor`)), session)
output$`tutorial-exercise-acre_data2-output` <- renderUI({
  `tutorial-exercise-acre_data2-result`()
})
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "acre_data2", global_setup = structure(c("", 
"source(\"RScripts/Chapter2_Setup.R\")", "source(\"RScripts/Chapter3_Setup.R\")", 
"source(\"RScripts/Chapter5_Setup.R\")", ""), chunk_opts = list(
    label = "setup", include = FALSE)), setup = NULL, chunks = list(
    list(label = "acre_data2", code = "\nlightfooti_data2 <- read.acre(\n  captures = captures,\n  traps = traps,\n  mask = mask,\n  loc_cov = cov_dat,\n  cue.rates = call_rates\n)\n", 
        opts = list(label = "\"acre_data2\"", exercise = "TRUE", 
            exercise.eval = "FALSE"), engine = "r")), code_check = NULL, 
    error_check = NULL, check = NULL, solution = NULL, tests = NULL, 
    options = list(eval = FALSE, echo = TRUE, results = "markup", 
        tidy = FALSE, tidy.opts = NULL, collapse = FALSE, prompt = FALSE, 
        comment = NA, highlight = FALSE, size = "normalsize", 
        background = "#F7F7F7", strip.white = TRUE, cache = 0, 
        cache.path = "00_Welcome_cache/html/", cache.vars = NULL, 
        cache.lazy = TRUE, dependson = NULL, autodep = FALSE, 
        cache.rebuild = FALSE, fig.keep = "high", fig.show = "asis", 
        fig.align = "default", fig.path = "00_Welcome_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 6.5, fig.height = 4, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 624, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = FALSE, error = FALSE, 
        message = FALSE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        max.print = 1000, label = "acre_data2", exercise = TRUE, 
        exercise.eval = FALSE, code = c("", "lightfooti_data2 <- read.acre(", 
        "  captures = captures,", "  traps = traps,", "  mask = mask,", 
        "  loc_cov = cov_dat,", "  cue.rates = call_rates", ")", 
        ""), out.width.px = 624, out.height.px = 384, params.src = "acre_data2, exercise=TRUE,exercise.eval=FALSE", 
        fig.num = 0, exercise.df_print = "paged", exercise.checker = "NULL"), 
    engine = "r", version = "4"), class = c("r", "tutorial_exercise"
)))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-model2-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-model2-code-editor`)), session)
output$`tutorial-exercise-model2-output` <- renderUI({
  `tutorial-exercise-model2-result`()
})
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "model2", global_setup = structure(c("", 
"source(\"RScripts/Chapter2_Setup.R\")", "source(\"RScripts/Chapter3_Setup.R\")", 
"source(\"RScripts/Chapter5_Setup.R\")", ""), chunk_opts = list(
    label = "setup", include = FALSE)), setup = NULL, chunks = list(
    list(label = "model2", code = "model2 <- fit.acre(\n  dat = lightfooti_data2,\n  detfn = \"hn\", \n  par_extend_model = list(D=~x),\n  fix = list(g0 = 1)\n)", 
        opts = list(label = "\"model2\"", exercise = "TRUE", 
            exercise.eval = "FALSE"), engine = "r")), code_check = NULL, 
    error_check = NULL, check = NULL, solution = NULL, tests = NULL, 
    options = list(eval = FALSE, echo = TRUE, results = "markup", 
        tidy = FALSE, tidy.opts = NULL, collapse = FALSE, prompt = FALSE, 
        comment = NA, highlight = FALSE, size = "normalsize", 
        background = "#F7F7F7", strip.white = TRUE, cache = 0, 
        cache.path = "00_Welcome_cache/html/", cache.vars = NULL, 
        cache.lazy = TRUE, dependson = NULL, autodep = FALSE, 
        cache.rebuild = FALSE, fig.keep = "high", fig.show = "asis", 
        fig.align = "default", fig.path = "00_Welcome_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 6.5, fig.height = 4, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 624, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = FALSE, error = FALSE, 
        message = FALSE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        max.print = 1000, label = "model2", exercise = TRUE, 
        exercise.eval = FALSE, code = c("model2 <- fit.acre(", 
        "  dat = lightfooti_data2,", "  detfn = \"hn\", ", "  par_extend_model = list(D=~x),", 
        "  fix = list(g0 = 1)", ")"), out.width.px = 624, out.height.px = 384, 
        params.src = "model2, exercise=TRUE,exercise.eval=FALSE", 
        fig.num = 0, exercise.df_print = "paged", exercise.checker = "NULL"), 
    engine = "r", version = "4"), class = c("r", "tutorial_exercise"
)))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-exercise1-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-exercise1-code-editor`)), session)
output$`tutorial-exercise-exercise1-output` <- renderUI({
  `tutorial-exercise-exercise1-result`()
})
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "exercise1", global_setup = structure(c("", 
"source(\"RScripts/Chapter2_Setup.R\")", "source(\"RScripts/Chapter3_Setup.R\")", 
"source(\"RScripts/Chapter5_Setup.R\")", ""), chunk_opts = list(
    label = "setup", include = FALSE)), setup = NULL, chunks = list(
    list(label = "exercise1", code = "", opts = list(label = "\"exercise1\"", 
        exercise = "TRUE", exercise.eval = "FALSE"), engine = "r")), 
    code_check = NULL, error_check = NULL, check = NULL, solution = structure(c("summary(model2)", 
    "show_detfn(model2)"), chunk_opts = list(label = "exercise1-solution")), 
    tests = NULL, options = list(eval = FALSE, echo = TRUE, results = "markup", 
        tidy = FALSE, tidy.opts = NULL, collapse = FALSE, prompt = FALSE, 
        comment = NA, highlight = FALSE, size = "normalsize", 
        background = "#F7F7F7", strip.white = TRUE, cache = 0, 
        cache.path = "00_Welcome_cache/html/", cache.vars = NULL, 
        cache.lazy = TRUE, dependson = NULL, autodep = FALSE, 
        cache.rebuild = FALSE, fig.keep = "high", fig.show = "asis", 
        fig.align = "default", fig.path = "00_Welcome_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 6.5, fig.height = 4, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 624, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = FALSE, error = FALSE, 
        message = FALSE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        max.print = 1000, label = "exercise1", exercise = TRUE, 
        exercise.eval = FALSE, code = "", out.width.px = 624, 
        out.height.px = 384, params.src = "exercise1, exercise=TRUE,exercise.eval=FALSE", 
        fig.num = 0L, exercise.df_print = "paged", exercise.checker = "NULL"), 
    engine = "r", version = "4"), class = c("r", "tutorial_exercise"
)))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-backtrans-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-backtrans-code-editor`)), session)
output$`tutorial-exercise-backtrans-output` <- renderUI({
  `tutorial-exercise-backtrans-result`()
})
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "backtrans", global_setup = structure(c("", 
"source(\"RScripts/Chapter2_Setup.R\")", "source(\"RScripts/Chapter3_Setup.R\")", 
"source(\"RScripts/Chapter5_Setup.R\")", ""), chunk_opts = list(
    label = "setup", include = FALSE)), setup = NULL, chunks = list(
    list(label = "backtrans", code = "\nexp(model2$coefficients[5]) # intercept \nexp(model2$coefficients[6]) # effect \n", 
        opts = list(label = "\"backtrans\"", exercise = "TRUE", 
            exercise.eval = "FALSE"), engine = "r")), code_check = NULL, 
    error_check = NULL, check = NULL, solution = NULL, tests = NULL, 
    options = list(eval = FALSE, echo = TRUE, results = "markup", 
        tidy = FALSE, tidy.opts = NULL, collapse = FALSE, prompt = FALSE, 
        comment = NA, highlight = FALSE, size = "normalsize", 
        background = "#F7F7F7", strip.white = TRUE, cache = 0, 
        cache.path = "00_Welcome_cache/html/", cache.vars = NULL, 
        cache.lazy = TRUE, dependson = NULL, autodep = FALSE, 
        cache.rebuild = FALSE, fig.keep = "high", fig.show = "asis", 
        fig.align = "default", fig.path = "00_Welcome_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 6.5, fig.height = 4, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 624, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = FALSE, error = FALSE, 
        message = FALSE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        max.print = 1000, label = "backtrans", exercise = TRUE, 
        exercise.eval = FALSE, code = c("", "exp(model2$coefficients[5]) # intercept ", 
        "exp(model2$coefficients[6]) # effect ", ""), out.width.px = 624, 
        out.height.px = 384, params.src = "backtrans, exercise=TRUE,exercise.eval=FALSE", 
        fig.num = 0, exercise.df_print = "paged", exercise.checker = "NULL"), 
    engine = "r", version = "4"), class = c("r", "tutorial_exercise"
)))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-exercise2-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-exercise2-code-editor`)), session)
output$`tutorial-exercise-exercise2-output` <- renderUI({
  `tutorial-exercise-exercise2-result`()
})
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "exercise2", global_setup = structure(c("", 
"source(\"RScripts/Chapter2_Setup.R\")", "source(\"RScripts/Chapter3_Setup.R\")", 
"source(\"RScripts/Chapter5_Setup.R\")", ""), chunk_opts = list(
    label = "setup", include = FALSE)), setup = NULL, chunks = list(
    list(label = "exercise2", code = "", opts = list(label = "\"exercise2\"", 
        exercise = "TRUE", exercise.eval = "FALSE"), engine = "r")), 
    code_check = NULL, error_check = NULL, check = NULL, solution = structure(c("model2_boot <- boot.acre(model2, N = 10) ", 
    "", "acre::stdEr(model2_boot)", "", "confint(model2_boot)"
    ), chunk_opts = list(label = "exercise2-solution")), tests = NULL, 
    options = list(eval = FALSE, echo = TRUE, results = "markup", 
        tidy = FALSE, tidy.opts = NULL, collapse = FALSE, prompt = FALSE, 
        comment = NA, highlight = FALSE, size = "normalsize", 
        background = "#F7F7F7", strip.white = TRUE, cache = 0, 
        cache.path = "00_Welcome_cache/html/", cache.vars = NULL, 
        cache.lazy = TRUE, dependson = NULL, autodep = FALSE, 
        cache.rebuild = FALSE, fig.keep = "high", fig.show = "asis", 
        fig.align = "default", fig.path = "00_Welcome_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 6.5, fig.height = 4, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 624, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = FALSE, error = FALSE, 
        message = FALSE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        max.print = 1000, label = "exercise2", exercise = TRUE, 
        exercise.eval = FALSE, code = "", out.width.px = 624, 
        out.height.px = 384, params.src = "exercise2, exercise=TRUE,exercise.eval=FALSE", 
        fig.num = 0L, exercise.df_print = "paged", exercise.checker = "NULL"), 
    engine = "r", version = "4"), class = c("r", "tutorial_exercise"
)))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-exercise3-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-exercise3-code-editor`)), session)
output$`tutorial-exercise-exercise3-output` <- renderUI({
  `tutorial-exercise-exercise3-result`()
})
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "exercise3", global_setup = structure(c("", 
"source(\"RScripts/Chapter2_Setup.R\")", "source(\"RScripts/Chapter3_Setup.R\")", 
"source(\"RScripts/Chapter5_Setup.R\")", ""), chunk_opts = list(
    label = "setup", include = FALSE)), setup = NULL, chunks = list(
    list(label = "exercise3", code = "", opts = list(label = "\"exercise3\"", 
        exercise = "TRUE", exercise.eval = "FALSE"), engine = "r")), 
    code_check = NULL, error_check = NULL, check = NULL, solution = structure(c("", 
    "show_Dsurf(model2, scale = 0.0001) # per hectare ", ""), chunk_opts = list(
        label = "exercise3-solution")), tests = NULL, options = list(
        eval = FALSE, echo = TRUE, results = "markup", tidy = FALSE, 
        tidy.opts = NULL, collapse = FALSE, prompt = FALSE, comment = NA, 
        highlight = FALSE, size = "normalsize", background = "#F7F7F7", 
        strip.white = TRUE, cache = 0, cache.path = "00_Welcome_cache/html/", 
        cache.vars = NULL, cache.lazy = TRUE, dependson = NULL, 
        autodep = FALSE, cache.rebuild = FALSE, fig.keep = "high", 
        fig.show = "asis", fig.align = "default", fig.path = "00_Welcome_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 6.5, fig.height = 4, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 624, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = FALSE, error = FALSE, 
        message = FALSE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        max.print = 1000, label = "exercise3", exercise = TRUE, 
        exercise.eval = FALSE, code = "", out.width.px = 624, 
        out.height.px = 384, params.src = "exercise3, exercise=TRUE,exercise.eval=FALSE", 
        fig.num = 0L, exercise.df_print = "paged", exercise.checker = "NULL"), 
    engine = "r", version = "4"), class = c("r", "tutorial_exercise"
)))
</script>
</p>
<!--html_preserve-->
<script type="application/shiny-prerendered" data-context="dependencies">
{"type":"list","attributes":{},"value":[{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["header-attrs"]},{"type":"character","attributes":{},"value":["2.23"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["rmd/h/pandoc"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["header-attrs.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["rmarkdown"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["2.23"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["jquery"]},{"type":"character","attributes":{},"value":["3.6.0"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/3.6.0"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["jquery-3.6.0.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["jquerylib"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.1.4"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["bootstrap"]},{"type":"character","attributes":{},"value":["3.3.5"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["rmd/h/bootstrap"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["viewport"]}},"value":[{"type":"character","attributes":{},"value":["width=device-width, initial-scale=1"]}]},{"type":"character","attributes":{},"value":["js/bootstrap.min.js","shim/html5shiv.min.js","shim/respond.min.js"]},{"type":"character","attributes":{},"value":["css/cerulean.min.css"]},{"type":"character","attributes":{},"value":["<style>h1 {font-size: 34px;}\n       h1.title {font-size: 38px;}\n       h2 {font-size: 30px;}\n       h3 {font-size: 24px;}\n       h4 {font-size: 18px;}\n       h5 {font-size: 16px;}\n       h6 {font-size: 12px;}\n       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}\n       pre:not([class]) { background-color: white }<\/style>"]},{"type":"NULL"},{"type":"character","attributes":{},"value":["rmarkdown"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["2.23"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["pagedtable"]},{"type":"character","attributes":{},"value":["1.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["rmd/h/pagedtable-1.1"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["js/pagedtable.js"]},{"type":"character","attributes":{},"value":["css/pagedtable.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["rmarkdown"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["2.23"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["highlightjs"]},{"type":"character","attributes":{},"value":["9.12.0"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["rmd/h/highlightjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["highlight.js"]},{"type":"character","attributes":{},"value":["textmate.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["rmarkdown"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["2.23"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["tutorial"]},{"type":"character","attributes":{},"value":["0.11.4.9000"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/tutorial"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["tutorial.js"]},{"type":"character","attributes":{},"value":["tutorial.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.11.4.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["i18n"]},{"type":"character","attributes":{},"value":["21.6.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/i18n"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["i18next.min.js","tutorial-i18n-init.js"]},{"type":"NULL"},{"type":"character","attributes":{},"value":["<script id=\"i18n-cstm-trns\" type=\"application/json\">{\"language\":\"en\",\"resources\":{\"en\":{\"translation\":{\"button\":{\"runcode\":\"Run Code\",\"runcodetitle\":\"$t(button.runcode) ({{kbd}})\",\"hint\":\"Hint\",\"hint_plural\":\"Hints\",\"hinttitle\":\"$t(button.hint)\",\"hintnext\":\"Next Hint\",\"hintprev\":\"Previous Hint\",\"solution\":\"Solution\",\"solutiontitle\":\"$t(button.solution)\",\"copyclipboard\":\"Copy to Clipboard\",\"startover\":\"Start Over\",\"startovertitle\":\"$t(button.startover)\",\"continue\":\"Continue\",\"submitanswer\":\"Submit Answer\",\"submitanswertitle\":\"$t(button.submitanswer)\",\"previoustopic\":\"Previous Topic\",\"nexttopic\":\"Next Topic\",\"questionsubmit\":\"$t(button.submitanswer)\",\"questiontryagain\":\"Try Again\"},\"text\":{\"startover\":\"Start Over\",\"areyousure\":\"Are you sure you want to start over? (all exercise progress will be reset)\",\"youmustcomplete\":\"You must complete the\",\"exercise\":\"exercise\",\"exercise_plural\":\"exercises\",\"inthissection\":\"in this section before continuing.\",\"code\":\"Code\",\"enginecap\":\"{{engine}} $t(text.code)\",\"quiz\":\"Quiz\",\"blank\":\"blank\",\"blank_plural\":\"blanks\",\"exercisecontainsblank\":\"This exercise contains {{count}} $t(text.blank).\",\"pleasereplaceblank\":\"Please replace {{blank}} with valid code.\",\"unparsable\":\"It looks like this might not be valid R code. R cannot determine how to turn your text into a complete command. You may have forgotten to fill in a blank, to remove an underscore, to include a comma between arguments, or to close an opening <code>&quot;<\\/code>, <code>'<\\/code>, <code>(<\\/code> or <code>{<\\/code> with a matching <code>&quot;<\\/code>, <code>'<\\/code>, <code>)<\\/code> or <code>}<\\/code>.\\n\",\"unparsablequotes\":\"<p>It looks like your R code contains specially formatted quotation marks or &quot;curly&quot; quotes (<code>{{character}}<\\/code>) around character strings, making your code invalid. R requires character values to be contained in straight quotation marks (<code>&quot;<\\/code> or <code>'<\\/code>).<\\/p> {{code}} <p>Don't worry, this is a common source of errors when you copy code from another app that applies its own formatting to text. You can try replacing the code on that line with the following. There may be other places that need to be fixed, too.<\\/p> {{suggestion}}\\n\",\"unparsableunicode\":\"<p>It looks like your R code contains an unexpected special character (<code>{{character}}<\\/code>) that makes your code invalid.<\\/p> {{code}} <p>Sometimes your code may contain a special character that looks like a regular character, especially if you copy and paste the code from another app. Try deleting the special character from your code and retyping it manually.<\\/p>\\n\",\"unparsableunicodesuggestion\":\"<p>It looks like your R code contains an unexpected special character (<code>{{character}}<\\/code>) that makes your code invalid.<\\/p> {{code}} <p>Sometimes your code may contain a special character that looks like a regular character, especially if you copy and paste the code from another app. You can try replacing the code on that line with the following. There may be other places that need to be fixed, too.<\\/p> {{suggestion}}\\n\",\"and\":\"and\",\"or\":\"or\",\"listcomma\":\", \",\"oxfordcomma\":\",\"}}},\"fr\":{\"translation\":{\"button\":{\"runcode\":\"Lancer le Code\",\"runcodetitle\":\"$t(button.runcode) ({{kbd}})\",\"hint\":\"Indication\",\"hint_plural\":\"Indications\",\"hinttitle\":\"$t(button.hint)\",\"hintnext\":\"Indication Suivante\",\"hintprev\":\"Indication Précédente\",\"solution\":\"Solution\",\"solutiontitle\":\"$t(button.solution)\",\"copyclipboard\":\"Copier dans le Presse-papier\",\"startover\":\"Recommencer\",\"startovertitle\":\"$t(button.startover)\",\"continue\":\"Continuer\",\"submitanswer\":\"Soumettre\",\"submitanswertitle\":\"$t(button.submitanswer)\",\"previoustopic\":\"Chapitre Précédent\",\"nexttopic\":\"Chapitre Suivant\",\"questionsubmit\":\"$t(button.submitanswer)\",\"questiontryagain\":\"Réessayer\"},\"text\":{\"startover\":\"Recommencer\",\"areyousure\":\"Êtes-vous certains de vouloir recommencer? (La progression sera remise à zéro)\",\"youmustcomplete\":\"Vous devez d'abord compléter\",\"exercise\":\"l'exercice\",\"exercise_plural\":\"des exercices\",\"inthissection\":\"de cette section avec de continuer.\",\"code\":\"Code\",\"enginecap\":\"$t(text.code) {{engine}}\",\"quiz\":\"Quiz\",\"and\":\"et\",\"or\":\"ou\",\"oxfordcomma\":\"\"}}},\"es\":{\"translation\":{\"button\":{\"runcode\":\"Ejecutar código\",\"runcodetitle\":\"$t(button.runcode) ({{kbd}})\",\"hint\":\"Pista\",\"hint_plural\":\"Pistas\",\"hinttitle\":\"$t(button.hint)\",\"hintnext\":\"Siguiente pista\",\"hintprev\":\"Pista anterior\",\"solution\":\"Solución\",\"solutiontitle\":\"$t(button.solution)\",\"copyclipboard\":\"Copiar al portapapeles\",\"startover\":\"Reiniciar\",\"startovertitle\":\"$t(button.startover)\",\"continue\":\"Continuar\",\"submitanswer\":\"Enviar respuesta\",\"submitanswertitle\":\"$t(button.submitanswer)\",\"previoustopic\":\"Tema anterior\",\"nexttopic\":\"Tema siguiente\",\"questionsubmit\":\"$t(button.submitanswer)\",\"questiontryagain\":\"Volver a intentar\"},\"text\":{\"startover\":\"Reiniciar\",\"areyousure\":\"¿De verdad quieres empezar de nuevo? (todo el progreso del ejercicio se perderá)\",\"youmustcomplete\":\"Debes completar\",\"exercise\":\"el ejercicio\",\"exercise_plural\":\"los ejercicios\",\"inthissection\":\"en esta sección antes de continuar.\",\"code\":\"Código\",\"enginecap\":\"$t(text.code) {{engine}}\",\"quiz\":\"Cuestionario\",\"and\":\"y\",\"or\":\"o\",\"oxfordcomma\":\"\"}}},\"pt\":{\"translation\":{\"button\":{\"runcode\":\"Executar código\",\"runcodetitle\":\"$t(button.runcode) ({{kbd}})\",\"hint\":\"Dica\",\"hint_plural\":\"Dicas\",\"hinttitle\":\"$t(button.hint)\",\"hintnext\":\"Próxima dica\",\"hintprev\":\"Dica anterior\",\"solution\":\"Solução\",\"solutiontitle\":\"$t(button.solution)\",\"copyclipboard\":\"Copiar para a área de transferência\",\"startover\":\"Reiniciar\",\"startovertitle\":\"$t(button.startover)\",\"continue\":\"Continuar\",\"submitanswer\":\"Enviar resposta\",\"submitanswertitle\":\"$t(button.submitanswer)\",\"previoustopic\":\"Tópico anterior\",\"nexttopic\":\"Próximo tópico\",\"questionsubmit\":\"$t(button.submitanswer)\",\"questiontryagain\":\"Tentar novamente\"},\"text\":{\"startover\":\"Reiniciar\",\"areyousure\":\"Tem certeza que deseja começar novamente? (todo o progresso feito será perdido)\",\"youmustcomplete\":\"Você deve completar\",\"exercise\":\"o exercício\",\"exercise_plural\":\"os exercícios\",\"inthissection\":\"nesta seção antes de continuar.\",\"code\":\"Código\",\"enginecap\":\"$t(text.code) {{engine}}\",\"quiz\":\"Quiz\",\"and\":\"e\",\"or\":\"ou\",\"oxfordcomma\":\"\"}}},\"tr\":{\"translation\":{\"button\":{\"runcode\":\"Çalıştırma Kodu\",\"runcodetitle\":\"$t(button.runcode) ({{kbd}})\",\"hint\":\"Ipucu\",\"hint_plural\":\"İpuçları\",\"hinttitle\":\"$t(button.hint)\",\"hintnext\":\"Sonraki İpucu\",\"hintprev\":\"Önceki İpucu\",\"solution\":\"Çözüm\",\"solutiontitle\":\"$t(button.solution)\",\"copyclipboard\":\"Pano'ya Kopyala\",\"startover\":\"Baştan Başlamak\",\"startovertitle\":\"$t(button.startover)\",\"continue\":\"Devam et\",\"submitanswer\":\"Cevabı onayla\",\"submitanswertitle\":\"$t(button.submitanswer)\",\"previoustopic\":\"Önceki Konu\",\"nexttopic\":\"Sonraki Konu\",\"questionsubmit\":\"$t(button.submitanswer)\",\"questiontryagain\":\"Tekrar Deneyin\"},\"text\":{\"startover\":\"Baştan Başlamak\",\"areyousure\":\"Baştan başlamak istediğinizden emin misiniz? (tüm egzersiz ilerlemesi kaybolacak)\",\"youmustcomplete\":\"Tamamlamalısın\",\"exercise\":\"egzersiz\",\"exercise_plural\":\"egzersizler\",\"inthissection\":\"devam etmeden önce bu bölümde\",\"code\":\"Kod\",\"enginecap\":\"$t(text.code) {{engine}}\",\"quiz\":\"Sınav\",\"oxfordcomma\":\"\"}}},\"emo\":{\"translation\":{\"button\":{\"runcode\":\"🏃\",\"runcodetitle\":\"$t(button.runcode) ({{kbd}})\",\"hint\":\"💡\",\"hint_plural\":\"$t(button.hint)\",\"hinttitle\":\"$t(button.hint)\",\"solution\":\"🎯\",\"solutiontitle\":\"$t(button.solution)\",\"copyclipboard\":\"📋\",\"startover\":\"⏮\",\"startovertitle\":\"Start Over\",\"continue\":\"✅\",\"submitanswer\":\"🆗\",\"submitanswertitle\":\"Submit Answer\",\"previoustopic\":\"⬅\",\"nexttopic\":\"➡\",\"questionsubmit\":\"$t(button.submitanswer)\",\"questiontryagain\":\"🔁\"},\"text\":{\"startover\":\"⏮\",\"areyousure\":\"🤔\",\"youmustcomplete\":\"⚠️ 👉 🧑‍💻\",\"exercise\":\"\",\"exercise_plural\":\"\",\"inthissection\":\"\",\"code\":\"💻\",\"enginecap\":\"$t(text.code) {{engine}}\",\"oxfordcomma\":\"\"}}},\"eu\":{\"translation\":{\"button\":{\"runcode\":\"Kodea egikaritu\",\"runcodetitle\":\"$t(button.runcode) ({{kbd}})\",\"hint\":\"Laguntza\",\"hint_plural\":\"Laguntza\",\"hinttitle\":\"$t(button.hint)\",\"hintnext\":\"Aurreko laguntza\",\"hintprev\":\"Hurrengo laguntza\",\"solution\":\"Ebazpena\",\"solutiontitle\":\"$t(button.solution)\",\"copyclipboard\":\"Arbelean kopiatu\",\"startover\":\"Berrabiarazi\",\"startovertitle\":\"$t(button.startover)\",\"continue\":\"Jarraitu\",\"submitanswer\":\"Erantzuna bidali\",\"submitanswertitle\":\"$t(button.submitanswer)\",\"previoustopic\":\"Aurreko atala\",\"nexttopic\":\"Hurrengo atala\",\"questionsubmit\":\"$t(button.submitanswer)\",\"questiontryagain\":\"Berriro saiatu\"},\"text\":{\"startover\":\"Berrabiarazi\",\"areyousure\":\"Berriro hasi nahi duzu? (egindako lana galdu egingo da)\",\"youmustcomplete\":\"Aurrera egin baino lehen atal honetako\",\"exercise\":\"ariketa egin behar duzu.\",\"exercise_plural\":\"ariketak egin behar dituzu.\",\"inthissection\":\"\",\"code\":\"Kodea\",\"enginecap\":\"$t(text.code) {{engine}}\",\"quiz\":\"Galdetegia\",\"oxfordcomma\":\"\"}}},\"de\":{\"translation\":{\"button\":{\"runcode\":\"Code ausführen\",\"runcodetitle\":\"$t(button.runcode) ({{kbd}})\",\"hint\":\"Tipp\",\"hint_plural\":\"Tipps\",\"hinttitle\":\"$t(button.hint)\",\"hintnext\":\"Nächster Tipp\",\"hintprev\":\"Vorheriger Tipp\",\"solution\":\"Lösung\",\"solutiontitle\":\"$t(button.solution)\",\"copyclipboard\":\"In die Zwischenablage kopieren\",\"startover\":\"Neustart\",\"startovertitle\":\"$t(button.startover)\",\"continue\":\"Weiter\",\"submitanswer\":\"Antwort einreichen\",\"submitanswertitle\":\"$t(button.submitanswer)\",\"previoustopic\":\"Vorheriges Kapitel\",\"nexttopic\":\"Nächstes Kapitel\",\"questionsubmit\":\"$t(button.submitanswer)\",\"questiontryagain\":\"Nochmal versuchen\"},\"text\":{\"startover\":\"Neustart\",\"areyousure\":\"Bist du sicher, dass du neustarten willst? (der gesamte Lernfortschritt wird gelöscht)\",\"youmustcomplete\":\"Vervollstädinge\",\"exercise\":\"die Übung\",\"exercise_plural\":\"die Übungen\",\"inthissection\":\"in diesem Kapitel, bevor du fortfährst.\",\"code\":\"Code\",\"enginecap\":\"$t(text.code) {{engine}}\",\"quiz\":\"Quiz\",\"blank\":\"Lücke\",\"blank_plural\":\"Lücken\",\"pleasereplaceblank\":\"Bitte ersetze {{blank}} mit gültigem Code.\",\"unparsable\":\"Dies scheint kein gültiger R Code zu sein. R kann deinen Text nicht in einen gültigen Befehl übersetzen. Du hast vielleicht vergessen, die Lücke zu füllen, einen Unterstrich zu entfernen, ein Komma zwischen Argumente zu setzen oder ein eröffnendes <code>&quot;<\\/code>, <code>'<\\/code>, <code>(<\\/code> oder <code>{<\\/code> mit einem zugehörigen <code>&quot;<\\/code>, <code>'<\\/code>, <code>)<\\/code> oder <code>}<\\/code> zu schließen.\\n\",\"and\":\"und\",\"or\":\"oder\",\"listcomma\":\", \",\"oxfordcomma\":\",\"}}},\"ko\":{\"translation\":{\"button\":{\"runcode\":\"코드 실행\",\"runcodetitle\":\"$t(button.runcode) ({{kbd}})\",\"hint\":\"힌트\",\"hint_plural\":\"힌트들\",\"hinttitle\":\"$t(button.hint)\",\"hintnext\":\"다음 힌트\",\"hintprev\":\"이전 힌트\",\"solution\":\"솔루션\",\"solutiontitle\":\"$t(button.solution)\",\"copyclipboard\":\"클립보드에 복사\",\"startover\":\"재학습\",\"startovertitle\":\"$t(button.startover)\",\"continue\":\"다음 학습으로\",\"submitanswer\":\"정답 제출\",\"submitanswertitle\":\"$t(button.submitanswer)\",\"previoustopic\":\"이전 토픽\",\"nexttopic\":\"다음 토픽\",\"questionsubmit\":\"$t(button.submitanswer)\",\"questiontryagain\":\"재시도\"},\"text\":{\"startover\":\"재학습\",\"areyousure\":\"다시 시작 하시겠습니까? (모든 예제의 진행 정보가 재설정됩니다)\",\"youmustcomplete\":\"당신은 완료해야 합니다\",\"exercise\":\"연습문제\",\"exercise_plural\":\"연습문제들\",\"inthissection\":\"이 섹션을 실행하기 전에\",\"code\":\"코드\",\"enginecap\":\"$t(text.code) {{engine}}\",\"quiz\":\"퀴즈\",\"blank\":\"공백\",\"blank_plural\":\"공백들\",\"exercisecontainsblank\":\"이 연습문제에는 {{count}}개의 $t(text.blank)이 포함되어 있습니다.\",\"pleasereplaceblank\":\"{{blank}}를 유효한 코드로 바꾸십시오.\",\"unparsable\":\"이것은 유효한 R 코드가 아닐 수 있습니다. R은 텍스트를 완전한 명령으로 변환하는 방법을 결정할 수 없습니다. 당신은 공백이나 밑줄을 대체하여 채우기, 인수를 컴마로 구분하기, 또는 <code>&quot;<\\/code>, <code>'<\\/code>, <code>(<\\/code> , <code>{<\\/code>로 시작하는 구문을 닫는 <code>&quot;<\\/code>, <code>'<\\/code>, <code>)<\\/code>, <code>}<\\/code>을 잊었을 수도 있습니다.\\n\",\"and\":\"그리고\",\"or\":\"혹은\",\"listcomma\":\", \",\"oxfordcomma\":\"\"}}},\"zh\":{\"translation\":{\"button\":{\"runcode\":\"运行代码\",\"runcodetitle\":\"$t(button.runcode) ({{kbd}})\",\"hint\":\"提示\",\"hint_plural\":\"提示\",\"hinttitle\":\"$t(button.hint)\",\"hintnext\":\"下一个提示\",\"hintprev\":\"上一个提示\",\"solution\":\"答案\",\"solutiontitle\":\"$t(button.solution)\",\"copyclipboard\":\"复制到剪切板\",\"startover\":\"重新开始\",\"startovertitle\":\"$t(button.startover)\",\"continue\":\"继续\",\"submitanswer\":\"提交答案\",\"submitanswertitle\":\"$t(button.submitanswer)\",\"previoustopic\":\"上一专题\",\"nexttopic\":\"下一专题\",\"questionsubmit\":\"$t(button.submitanswer)\",\"questiontryagain\":\"再试一次\"},\"text\":{\"startover\":\"重置\",\"areyousure\":\"你确定要重新开始吗? (所有当前进度将被重置)\",\"youmustcomplete\":\"你必须完成\",\"exercise\":\"练习\",\"exercise_plural\":\"练习\",\"inthissection\":\"在进行本节之前\",\"code\":\"代码\",\"enginecap\":\"$t(text.code) {{engine}}\",\"quiz\":\"测试\",\"blank\":\"空\",\"blank_plural\":\"空\",\"exercisecontainsblank\":\"本练习包含{{count}}个$t(text.blank)\",\"pleasereplaceblank\":\"请在{{blank}}内填写恰当的代码\",\"unparsable\":\"这似乎不是有效的R代码。 R不知道如何将您的文本转换为完整的命令。 您是否忘了填空，忘了删除下划线，忘了在参数之间包含逗号，或者是忘了用<code>&quot;<\\/code>, <code>'<\\/code>, <code>)<\\/code>,<code>}<\\/code>来封闭<code>&quot;<\\/code>, <code>'<\\/code>, <code>(<\\/code>。 or <code>{<\\/code>。\\n\",\"unparsablequotes\":\"<p>您的R代码中似乎含有特殊格式的引号，或者弯引号(<code>{{character}}<\\/code>) 在字符串前后，在R中字符串应该被直引号(<code>&quot;<\\/code> 或者 <code>'<\\/code>)包裹。<\\/p> {{code}} <p>别担心，该错误经常在复制粘贴包含格式的代码时遇到， 您可以尝试将该行中的代码替换为以下代码，也许还有其他地方需要修改。<\\/p> {{suggestion}}\\n\",\"unparsableunicode\":\"<p>您的代码中似乎包含有异常字符(<code>{{character}}<\\/code>),导致代码无效。<\\/p> {{code}} <p>有时候你的代码可能含有看似正常字符的特殊字符，特别是当你复制粘贴其他来源代码的时候。 请试着删除这些特殊字符,重新输入<\\/p>\\n\",\"unparsableunicodesuggestion\":\"<p>您的代码中似乎包含有异常字符(<code>{{character}}<\\/code>),导致代码无效。<\\/p> {{code}} <p>有时候你的代码可能含有看似正常字符的特殊字符，特别是当你复制粘贴其他来源代码的时候。 请试着删除这些特殊字符,重新输入<\\/p>\\n\",\"and\":\"且\",\"or\":\"或\",\"listcomma\":\",\",\"oxfordcomma\":\",\"}}},\"pl\":{\"translation\":{\"button\":{\"runcode\":\"Uruchom kod\",\"runcodetitle\":\"$t(button.runcode) ({{kbd}})\",\"hint\":\"Podpowiedź\",\"hint_plural\":\"Podpowiedzi\",\"hinttitle\":\"$t(button.hint)\",\"hintnext\":\"Następna podpowiedź\",\"hintprev\":\"Poprzednia podpowiedź\",\"solution\":\"Rozwiązanie\",\"solutiontitle\":\"$t(button.solution)\",\"copyclipboard\":\"Kopiuj do schowka\",\"startover\":\"Zacznij od początku\",\"startovertitle\":\"$t(button.startover)\",\"continue\":\"Kontynuuj\",\"submitanswer\":\"Wyślij\",\"submitanswertitle\":\"$t(button.submitanswer)\",\"previoustopic\":\"Poprzednia sekcja\",\"nexttopic\":\"Następna sekcja\",\"questionsubmit\":\"$t(button.submitanswer)\",\"questiontryagain\":\"Spróbuj ponownie\"},\"text\":{\"startover\":\"Zacznij od początku\",\"areyousure\":\"Czy na pewno chcesz zacząć od początku? (cały postęp w zadaniu zostanie utracony)\",\"youmustcomplete\":\"Musisz ukończyć\",\"exercise\":\"ćwiczenie\",\"exercise_plural\":\"ćwiczenia\",\"inthissection\":\"w tej sekcji przed kontynuowaniem\",\"code\":\"Kod\",\"enginecap\":\"$t(text.code) {{engine}}\",\"quiz\":\"Quiz\",\"blank\":\"luka\",\"blank_plural\":\"luk(i)\",\"exercisecontainsblank\":\"To ćwiczenie zawiera {{count}} $t(text.blank).\",\"pleasereplaceblank\":\"Proszę uzupełnić {{blank}} prawidłowym kodem.\",\"unparsable\":\"Wygląda na to, że może to nie być prawidłowy kod R. R nie jest w stanie przetworzyć Twojego tekstu na polecenie. Mogłeś(-aś) zapomnieć wypełnić luki, usunąć podkreślnik, umieścić przecinka między argumentami, lub zamknąć znak <code>&quot;<\\/code>, <code>'<\\/code>, <code>(<\\/code> lub <code>{<\\/code> odpowiadającym <code>&quot;<\\/code>, <code>'<\\/code>, <code>)<\\/code> lub <code>}<\\/code>.\\n\",\"unparsablequotes\":\"<p>Wygląda na to, że Twój kod zawiera szczególnie sformatowane cudzysłowy lub cudzysłowy typograficzne (<code>{{character}}<\\/code>) przy ciągach znaków, co sprawia, że kod jest niepoprawny. R wymaga cudzysłowów prostych (<code>&quot;<\\/code> albo <code>'<\\/code>).<\\/p> {{code}} <p>Nie martw się, to powszechne źródło błędów, gdy kopiuje się kod z innego programu, który sam formatuje teskt. Możesz spróbować zastąpić swój kod następującym kodem. Mogą być też inne miejsca, które wymagają poprawienia.<\\/p> {{suggestion}}\\n\",\"unparsableunicode\":\"<p>Wygląda na to, że Twój kod zawiera niespodziewany znak specjalny (<code>{{character}}<\\/code>), co sprawia, że kod jest niepoprawny.<\\/p> {{code}} <p>Czasami Twój kod może zawierać znak specjalny, który wygląda jak zwykły znak, zwłaszcza jeśli kopiujesz kod z innego programu. Spróbuj usunąć znak specjalny i wpisać do ponownie ręcznie.<\\/p>\\n\",\"unparsableunicodesuggestion\":\"<p>Wygląda na to, że Twój kod zawiera niespodziewany znak specjalny (<code>{{character}}<\\/code>), co sprawia, że kod jest niepoprawny.<\\/p> {{code}} <p>Czasami Twój kod może zawierać znak specjalny, który wygląda jak zwykły znak, zwłaszcza jeśli kopiujesz kod z innego programu. Możesz spróbować zastąpić swój kod następującym kodem. Mogą być też inne miejsca, które wymagają poprawienia.<\\/p> {{suggestion}}\\n\",\"and\":\"i\",\"or\":\"lub\",\"listcomma\":\", \",\"oxfordcomma\":\"\"}}}}}<\/script>"]},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.11.4.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["tutorial-format"]},{"type":"character","attributes":{},"value":["0.11.4.9000"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["rmarkdown/templates/tutorial/resources"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["tutorial-format.js"]},{"type":"character","attributes":{},"value":["tutorial-format.css","rstudio-theme.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.11.4.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["jquery"]},{"type":"character","attributes":{},"value":["3.6.0"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/3.6.0"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["jquery-3.6.0.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["jquerylib"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.1.4"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["navigation"]},{"type":"character","attributes":{},"value":["1.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["rmd/h/navigation-1.1"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["tabsets.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["rmarkdown"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["2.23"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["highlightjs"]},{"type":"character","attributes":{},"value":["9.12.0"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["rmd/h/highlightjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["highlight.js"]},{"type":"character","attributes":{},"value":["default.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["rmarkdown"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["2.23"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["jquery"]},{"type":"character","attributes":{},"value":["3.6.0"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/3.6.0"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["jquery-3.6.0.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["jquerylib"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.1.4"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["font-awesome"]},{"type":"character","attributes":{},"value":["6.4.0"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["fontawesome"]}]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["css/all.min.css","css/v4-shims.min.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["fontawesome"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.5.1"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["bootbox"]},{"type":"character","attributes":{},"value":["5.5.2"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/bootbox"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["bootbox.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.11.4.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["idb-keyvalue"]},{"type":"character","attributes":{},"value":["3.2.0"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/idb-keyval"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["idb-keyval-iife-compat.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[false]},{"type":"character","attributes":{},"value":["0.11.4.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["tutorial"]},{"type":"character","attributes":{},"value":["0.11.4.9000"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/tutorial"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["tutorial.js"]},{"type":"character","attributes":{},"value":["tutorial.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.11.4.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["htmlwidgets"]},{"type":"character","attributes":{},"value":["1.6.2"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["www"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["htmlwidgets.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["htmlwidgets"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["1.6.2"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["datatables-css"]},{"type":"character","attributes":{},"value":["0.0.0"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["htmlwidgets/css"]}]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["datatables-crosstalk.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["DT"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.27"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["datatables-binding"]},{"type":"character","attributes":{},"value":["0.27"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["htmlwidgets"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["datatables.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["DT"]},{"type":"logical","attributes":{},"value":[false]},{"type":"character","attributes":{},"value":["0.27"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["jquery"]},{"type":"character","attributes":{},"value":["3.5.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/jquery"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["jquery.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["crosstalk"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["1.2.0"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["crosstalk"]},{"type":"character","attributes":{},"value":["1.2.0"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["www"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["js/crosstalk.min.js"]},{"type":"character","attributes":{},"value":["css/crosstalk.min.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["crosstalk"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["1.2.0"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["htmlwidgets"]},{"type":"character","attributes":{},"value":["1.6.2"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["www"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["htmlwidgets.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["htmlwidgets"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["1.6.2"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["plotly-binding"]},{"type":"character","attributes":{},"value":["4.10.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["htmlwidgets"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["plotly.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["plotly"]},{"type":"logical","attributes":{},"value":[false]},{"type":"character","attributes":{},"value":["4.10.1"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["htmlwidgets"]},{"type":"character","attributes":{},"value":["1.6.2"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["www"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["htmlwidgets.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["htmlwidgets"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["1.6.2"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["plotly-binding"]},{"type":"character","attributes":{},"value":["4.10.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["htmlwidgets"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["plotly.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["plotly"]},{"type":"logical","attributes":{},"value":[false]},{"type":"character","attributes":{},"value":["4.10.1"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ionrangeslider-skin"]},{"type":"character","attributes":{},"value":["0.7.6"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["href","file"]}},"value":[{"type":"character","attributes":{},"value":["shinyWidgets/ion-rangeslider"]},{"type":"character","attributes":{},"value":["assets/ion-rangeslider"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["jquery.initialize.min.js","custom-skin.js"]},{"type":"character","attributes":{},"value":["ion.rangeSlider.min.css"]},{"type":"character","attributes":{},"value":["<script type='custom-slider-skin'>{\"name\":\"flat\"}<\/script>"]},{"type":"NULL"},{"type":"character","attributes":{},"value":["shinyWidgets"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.7.6"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["selectize"]},{"type":"character","attributes":{},"value":["0.12.4"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["www/shared/selectize"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["js/selectize.min.js","accessibility/js/selectize-plugin-a11y.min.js"]},{"type":"character","attributes":{},"value":["css/selectize.bootstrap3.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["shiny"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["1.7.4"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ionrangeslider-javascript"]},{"type":"character","attributes":{},"value":["2.3.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["www/shared/ionrangeslider"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["js/ion.rangeSlider.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["shiny"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["1.7.4"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["strftime"]},{"type":"character","attributes":{},"value":["0.9.2"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["www/shared/strftime"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["strftime-min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["shiny"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["1.7.4"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ionrangeslider-css"]},{"type":"character","attributes":{},"value":["2.3.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["www/shared/ionrangeslider"]}]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["css/ion.rangeSlider.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["shiny"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["1.7.4"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["jquery"]},{"type":"character","attributes":{},"value":["3.6.0"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["www/shared"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["jquery.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["shiny"]},{"type":"logical","attributes":{},"value":[false]},{"type":"character","attributes":{},"value":["1.7.4"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ionrangeslider-javascript"]},{"type":"character","attributes":{},"value":["2.3.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["www/shared/ionrangeslider"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["js/ion.rangeSlider.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["shiny"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["1.7.4"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["strftime"]},{"type":"character","attributes":{},"value":["0.9.2"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["www/shared/strftime"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["strftime-min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["shiny"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["1.7.4"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ionrangeslider-css"]},{"type":"character","attributes":{},"value":["2.3.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["www/shared/ionrangeslider"]}]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["css/ion.rangeSlider.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["shiny"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["1.7.4"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["bootstrap"]},{"type":"character","attributes":{},"value":["3.4.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["www/shared/bootstrap"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["viewport"]}},"value":[{"type":"character","attributes":{},"value":["width=device-width, initial-scale=1"]}]},{"type":"character","attributes":{},"value":["js/bootstrap.min.js","accessibility/js/bootstrap-accessibility.min.js"]},{"type":"character","attributes":{},"value":["css/bootstrap.min.css","accessibility/css/bootstrap-accessibility.min.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["shiny"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["1.7.4"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["jquery"]},{"type":"character","attributes":{},"value":["3.6.0"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["www/shared"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["jquery.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["shiny"]},{"type":"logical","attributes":{},"value":[false]},{"type":"character","attributes":{},"value":["1.7.4"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ionrangeslider-javascript"]},{"type":"character","attributes":{},"value":["2.3.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["www/shared/ionrangeslider"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["js/ion.rangeSlider.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["shiny"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["1.7.4"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["strftime"]},{"type":"character","attributes":{},"value":["0.9.2"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["www/shared/strftime"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["strftime-min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["shiny"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["1.7.4"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ionrangeslider-css"]},{"type":"character","attributes":{},"value":["2.3.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["www/shared/ionrangeslider"]}]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["css/ion.rangeSlider.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["shiny"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["1.7.4"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["bootstrap"]},{"type":"character","attributes":{},"value":["3.4.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["www/shared/bootstrap"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["viewport"]}},"value":[{"type":"character","attributes":{},"value":["width=device-width, initial-scale=1"]}]},{"type":"character","attributes":{},"value":["js/bootstrap.min.js","accessibility/js/bootstrap-accessibility.min.js"]},{"type":"character","attributes":{},"value":["css/bootstrap.min.css","accessibility/css/bootstrap-accessibility.min.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["shiny"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["1.7.4"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["jquery"]},{"type":"character","attributes":{},"value":["3.6.0"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["www/shared"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["jquery.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["shiny"]},{"type":"logical","attributes":{},"value":[false]},{"type":"character","attributes":{},"value":["1.7.4"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["bootstrap"]},{"type":"character","attributes":{},"value":["3.4.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["www/shared/bootstrap"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["viewport"]}},"value":[{"type":"character","attributes":{},"value":["width=device-width, initial-scale=1"]}]},{"type":"character","attributes":{},"value":["js/bootstrap.min.js","accessibility/js/bootstrap-accessibility.min.js"]},{"type":"character","attributes":{},"value":["css/bootstrap.min.css","accessibility/css/bootstrap-accessibility.min.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["shiny"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["1.7.4"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.10.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.11.4.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.11.4.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.10.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.11.4.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.11.4.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.10.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.11.4.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.11.4.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.10.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.11.4.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.11.4.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.10.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.11.4.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.11.4.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.10.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.11.4.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.11.4.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.10.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.11.4.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.11.4.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.10.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.11.4.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.11.4.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.10.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.11.4.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.11.4.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.10.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.11.4.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.11.4.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.10.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.11.4.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.11.4.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.10.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.11.4.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.11.4.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.10.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.11.4.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.11.4.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.10.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.11.4.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.11.4.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.10.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.11.4.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.11.4.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.10.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.11.4.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.11.4.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.10.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.11.4.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.11.4.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.10.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.11.4.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.11.4.9000"]}]}]}
</script>
<!--/html_preserve-->
<!--html_preserve-->
<script type="application/shiny-prerendered" data-context="execution_dependencies">
{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["packages"]}},"value":[{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["packages","version"]},"class":{"type":"character","attributes":{},"value":["data.frame"]},"row.names":{"type":"integer","attributes":{},"value":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143]}},"value":[{"type":"character","attributes":{},"value":["abind","acre","ash","backports","base","brio","bslib","cachem","checkmate","class","classInt","cli","codetools","colorspace","commonmark","compiler","crayon","crosstalk","data.table","datasets","DBI","digest","dplyr","DT","e1071","ellipsis","evaluate","extrafont","extrafontdb","fansi","farver","fastmap","fontawesome","forcats","generics","ggalt","gganimate","ggforce","ggfun","ggimage","ggplot2","ggplotify","glue","graphics","grDevices","grid","gridExtra","gridGraphics","gtable","highr","hms","htmltools","htmlwidgets","httpuv","httr","jquerylib","jsonlite","kableExtra","KernSmooth","knitr","labeling","later","lattice","lazyeval","learnr","lifecycle","lubridate","magick","magrittr","maps","markdown","MASS","Matrix","memoise","methods","metR","mgcv","mime","munsell","nlme","parallel","pillar","pkgconfig","plotly","polyclip","prettyunits","progress","proj4","promises","proxy","purrr","R6","raster","RColorBrewer","Rcpp","RcppNumerical","RcppParallel","readr","rlang","rmarkdown","rprojroot","rstudioapi","Rttf2pt1","rvest","sass","scales","secr","sf","shiny","shinydashboard","shinyWidgets","sp","splines","stats","stringi","stringr","svglite","systemfonts","terra","testthat","tibble","tidyr","tidyselect","tidyverse","timechange","tippy","TMB","tools","tweenr","tzdb","units","utf8","utils","vctrs","viridis","viridisLite","webshot","withr","xfun","xml2","xtable","yaml","yulab.utils"]},{"type":"character","attributes":{},"value":["1.4-5","0.1.0","1.0-15","1.4.1","4.2.2","1.1.3","0.5.0","1.0.8","2.2.0","7.3-21","0.4-9","3.6.1","0.2-19","2.1-0","1.9.0","4.2.2","1.5.2","1.2.0","1.14.8","4.2.2","1.1.3","0.6.33","1.1.2","0.27","1.7-13","0.3.2","0.21","0.19","1.0","1.0.4","2.1.1","1.1.1","0.5.1","1.0.0","0.1.3","0.4.0","1.0.8","0.4.1","0.1.1","0.3.3","3.4.3","0.1.1","1.6.2","4.2.2","4.2.2","4.2.2","2.3","0.5-1","0.3.3","0.10","1.1.3","0.5.5","1.6.2","1.6.11","1.4.6","0.1.4","1.8.7","1.3.4","2.23-20","1.43","0.4.2","1.3.1","0.20-45","0.2.2","0.11.4.9000","1.0.3","1.9.2","2.7.4","2.0.3","3.4.1","1.7","7.3-58.3","1.5-3","2.0.1","4.2.2","0.14.0","1.8-42","0.12","0.5.0","3.1-162","4.2.2","1.9.0","2.0.3","4.10.1","1.10-4","1.1.1","1.2.2","1.0-12","1.2.0.1","0.4-27","1.0.1","2.5.1","3.6-23","1.1-3","1.0.11","0.5-0","5.1.7","2.1.4","1.1.1","2.23","2.0.3","0.14","1.3.12","1.0.3","0.4.6","1.2.1","4.6.1","1.0-14","1.7.4","0.7.2","0.7.6","2.0-0","4.2.2","4.2.2","1.7.12","1.5.0","2.1.1","1.0.4","1.7-39","3.1.10","3.2.1","1.3.0","1.2.0","2.0.0","0.2.0","0.1.0","1.9.6","4.2.2","2.0.2","0.4.0","0.8-3","1.2.3","4.2.2","0.6.3","0.6.4","0.4.2","0.5.4","2.5.0","0.39","1.3.4","1.8-4","2.3.7","0.0.6"]}]}]}
</script>
<!--/html_preserve-->
</div>

</article> <!-- topics -->

<div class="topicsContainer">
<div class="topicsPositioner">
<div class="band">
<div class="bandContent topicsListContainer">

<!-- begin doc-metadata -->
<div id="doc-metadata">
<h1 class="title toc-ignore" style="display:none;">ASCR Tutorial</h1>
</div>
<!-- end doc-metadata -->

</div> <!-- bandContent.topicsListContainer -->
</div> <!-- band -->
</div> <!-- topicsPositioner -->
</div> <!-- topicsContainer -->


</main> <!-- bandContent page -->
</div> <!-- pageContent band -->



<!-- Build Tabsets -->
<script>
$(document).ready(function () {
  window.buildTabsets("section-TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open')
  });
});
</script>

<script>
// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});
</script>


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>


</body>

</html>
